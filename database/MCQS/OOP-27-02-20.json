[
    {
        "Questions": "Which was the first purely object oriented programming language developed?",
        "A": "Java",
        "B": "C++",
        "C": "SmallTalk",
        "D": " Kotlin",
        "Answer": "C",
        "Explanation": "SmallTalk was the first programming language developed which was  purely object oriented. It was developed by Alan Kay. OOP concept came into picture in 1970’s.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Which of the following best defines a class?",
        "A": "Parent of an object",
        "B": "Instance of an object",
        "C": "Blueprint of an object",
        "D": " Scope of an object",
        "Answer": "B",
        "Explanation": "A class is Blueprint of an object which describes/ shows all the functions and data that are provided by an object of a specific class. It can’t be called as parent or instance of an object. Class in general describes all the properties of an object.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Who invented OOP?",
        "A": "Alan Kay",
        "B": "Andrea Ferro",
        "C": "Dennis Ritchie",
        "D": "Adele Goldberg",
        "Answer": "A",
        "Explanation": "Alan Kay invented OOP, Andrea Ferro was a part of SmallTalk Development. Dennis invented C++ and Adele Goldberg was in team to develop SmallTalk but Alan actually had got rewarded for OOP.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "What is the additional feature in classes that was not in structures?",
        "A": "Data members",
        "B": "Member functions",
        "C": "Static data allowed",
        "D": " Public access specifier",
        "Answer": "B",
        "Explanation": "Member functions are allowed inside a class but were not present in structure concept. Data members, static data and public access specifiers were present in structures too.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which is not feature of OOP in general definitions?",
        "A": "Code reusability",
        "B": "Modularity",
        "C": "Duplicate/Redundant data",
        "D": "Efficient Code",
        "Answer": "C",
        "Explanation": " Duplicate/Redundant data is dependent on programmer and hence can’t be guaranteed by OOP. Code reusability is done using inheritance. Modularity is supported by using different code files and classes. Codes are more efficient because of features of OOP.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Which Feature of OOP illustrated the code reusability?",
        "A": "Polymorphism",
        "B": "Abstraction",
        "C": "Encapsulation",
        "D": "Inheritance",
        "Answer": "D",
        "Explanation": "Using inheritance we can reuse the code already written and also can avoid creation of many new functions or variables, as that can be done one time and be reused, using classes",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which language does not support all 4 types of inheritance?",
        "A": "C++",
        "B": "Java",
        "C": "Kotlin",
        "D": "Small Talk",
        "Answer": "B",
        "Explanation": "Java doesn’t support all 4 types of inheritance. It doesn’t support multiple inheritance. But the multiple inheritance can be implemented using interfaces in Java.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "How many classes can be defined in a single program?",
        "A": "Only 1",
        "B": "Only 100",
        "C": "Only 999",
        "D": "As many as you want",
        "Answer": "D",
        "Explanation": "Any number of classes can be defined inside a program, provided that their names are different. In java, if public class is present then it must have the same name as that of file.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "When OOP concept did first came into picture?",
        "A": "1970’s",
        "B": "1980’s",
        "C": "1993",
        "D": "1995",
        "Answer": "A",
        "Explanation": "OOP first came into picture in 1970’s by Alan and his team. Later it was used by some programming languages and got implemented successfully, SmallTalk was first language to use pure OOP and followed all rules strictly.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Why Java is Partially OOP language?",
        "A": "It supports usual declaration of primitive data types",
        "B": "It doesn’t support all types of inheritance",
        "C": "It allows code to be written outside classes",
        "D": "It does not support pointers",
        "Answer": "A",
        "Explanation": "As Java supports usual declaration of data variables, it is partial implementation of OOP. Because according to rules of OOP, object constructors must be used, even for declaration of variables.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which concept of OOP is false for C++?",
        "A": "Code can be written without using classes",
        "B": "Code must contain at least one class",
        "C": "A class must have member functions",
        "D": "At least one object should be declared in code",
        "Answer": "B",
        "Explanation": "In C++, it’s not necessary to use classes, and hence codes can be written without using OOP concept. Classes may or may not contain member functions, so it’s not a necessary condition in C++. And, an object can only be declared in a code if its class is defined/included via header file advertisement.\r\n",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which header file is required in C++ to use OOP?",
        "A": "iostream.h",
        "B": "stdio.h",
        "C": " stdlib.h",
        "D": "OOP can be used without using any header file",
        "Answer": "D",
        "Explanation": "We need not include any specific header file to use OOP concept in C++, only specific functions used in code need their respective header files to be included or classes should be defined if needed.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Which of the two features match each other?",
        "A": "Inheritance and Encapsulation",
        "B": "Encapsulation and Polymorphism",
        "C": "Encapsulation and Abstraction",
        "D": "Abstraction and Polymorphism",
        "Answer": "C",
        "Explanation": "Explanation: Encapsulation and Abstraction are similar features. Encapsulation is actually binding all the properties in a single class or we can say hiding all the features of object inside a class. And Abstraction is hiding unwanted data (for user) and showing only the data required by the user of program.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which feature allows open recursion, among the following?",
        "A": "Use of this pointer",
        "B": "Use of pointers",
        "C": "Use of pass by value",
        "D": "Use of parameterized constructor",
        "Answer": "A",
        "Explanation": "Use of this pointer allows an object to call data and methods of itself whenever needed. This helps us call the members of an object recursively, and differentiate the variables of different scopes.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which of the following is not type of class?",
        "A": "Abstract Class",
        "B": "Final Class",
        "C": "Start Class",
        "D": "String Class",
        "Answer": "C",
        "Explanation": "Only 9 types of classes are provided in general, namely, abstract, final, mutable, wrapper, anonymous, input-output, string, system, network. We may further divide the classes into parent class and subclass if inheritance is used.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Class is pass by _______  ",
        "A": "Value",
        "B": "Reference",
        "C": " Value or Reference, depending on program",
        "D": " Copy",
        "Answer": "B",
        "Explanation": "Classes are pass by reference, and the structures are pass by copy. It doesn’t depend on program.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "What is default access specifier for data members or member functions declared within a class without any specifier, in C++ ?       ",
        "A": "Private",
        "B": "Protected",
        "C": "Public",
        "D": "Depends on compiler",
        "Answer": "A",
        "Explanation": "The data members and member functions are Private by default in C++ classes, if none of the access specifier is used. It is actually made to increase the privacy of data",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which is most appropriate comment on following class definition:        \r\nclass Student                 \r\n{\r\n    int a; \r\n    public : float a; \r\n};\r\n   ",
        "A": "Error : same variable name can’t be used twice",
        "B": "Error : Public must come first",
        "C": "Error : data types are different for same variable",
        "D": "It is correct",
        "Answer": "A",
        "Explanation": "Same variable can’t be defined twice in same scope. Even if the data types are different, variable name must be different. There is no rule like Public member should come first or last.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Which is known as generic class?                         ",
        "A": "Abstract class",
        "B": "Final class",
        "C": "Template class",
        "D": "Efficient Code",
        "Answer": "C",
        "Explanation": "Template classes are known to be generic classes because those can be used for any data type value and the same class can be used for all the variables of different data types",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Size of a class is :                                           ",
        "A": "Sum of size of all the variables declared inside the class     ",
        "B": "Sum of size of all the variables along with inherited variables in the class",
        "C": "Size of largest size of variable",
        "D": "Classes doesn’t have any size",
        "Answer": "D",
        "Explanation": "Classes doesn’t have any size, actually the size of object of the class can be defined. That is done only when an object is created and its constructor is called.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Which class can have member functions without their implementation?         ",
        "A": "Default class",
        "B": "String class",
        "C": "Template class",
        "D": " Abstract class",
        "Answer": "D",
        "Explanation": "Abstract classes can have member functions with no implementation, where the inheriting subclasses must implement those functions.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which of the following describes a friend class?                          ",
        "A": "Friend class can access all the private members of the class, of which it is a friend",
        "B": "Friend class can only access protected members of the class, of which it is a friend",
        "C": "Friend class don’t have any implementation",
        "D": "Friend class can’t access any data member of another class but can use it’s methods",
        "Answer": "A",
        "Explanation": "A friend class can access all the private members of another class, of which it is friend. It is a special class provided to use when you need to reuse the data of a class but don’t want that class to have those special functions",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "What is scope of a class nested inside another class?                       ",
        "A": "Protected scope",
        "B": "Private scope",
        "C": "Global scope",
        "D": "Depends on access specifier and inheritance used",
        "Answer": "D",
        "Explanation": "It depends on the access specifier and the type of inheritance used with the class, because if the class is inherited then the nested class can be used by subclass too, provided it’s not of private type.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which among the following is false, for member function of a class?       ",
        "A": " All member functions must be defined",
        "B": "Member functions can be defined inside or outside the class body",
        "C": "Member functions need not be declared inside the class definition",
        "D": "Member functions can be made friend to another class using friend keyword",
        "Answer": "C",
        "Explanation": "Member functions must be declared inside class body, thought the definition can be given outside the class body. There is no way to declare the member functions inside the class.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which syntax for class definition is wrong?                    ",
        "A": " class student{ };",
        "B": "student class{ };",
        "C": "class student{ public: student(int a){ } };",
        "D": "class student{ student(int a){} };",
        "Answer": "B",
        "Explanation": "Keyword class should come first. Class name should come after keyword class. Parameterized constructor definition depends on programmer so it can be left empty also",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Which of the following pairs are similar?                          ",
        "A": "Class and object",
        "B": "Class and structure",
        "C": "Structure and object ",
        "D": "Structure and functions",
        "Answer": "B",
        "Explanation": "Class and structure are similar to each other. Only major difference is that a structure doesn’t have member functions whereas the class can have both data members and member functions.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which among the following is false for class features?                         ",
        "A": "Classes may/may not have both data members and member functions",
        "B": "Class definition must be ended with a colon",
        "C": "Class can have only member functions with no data members",
        "D": "Class is similar to union and structures",
        "Answer": "B",
        "Explanation": "Class definition must end with a semicolon, not colon. Class can have only member functions in its body with no data members.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Instance of which type of class can’t be created?              ",
        "A": " Anonymous class",
        "B": "Nested class",
        "C": "Parent class",
        "D": "Abstract class",
        "Answer": "D",
        "Explanation": "Instance of abstract class can’t be created as it will not have any constructor of its own, hence while creating an instance of class, it can’t initialize the object members. Actually the class inheriting the abstract class can have its instance, because it will have implementation of all members.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which definition best describes an object?                   ",
        "A": "Instance of a class",
        "B": "Instance of itself",
        "C": "Child of a class",
        "D": "Overview of a class",
        "Answer": "A",
        "Explanation": " An object is instance of its class. It can be declared in the same way that a variable is declared, only thing is you have to use class name as the data type",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "How many objects can be declared of a specific class in a single program?              ",
        "A": "32768",
        "B": "127",
        "C": "1",
        "D": "As many as you want",
        "Answer": "D",
        "Explanation": "You can create as many objects of a specific class as you want, provided enough memory is available.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Which among the following is false?                               ",
        "A": "Object must be created before using members of a class",
        "B": "Memory for an object is allocated only after its constructor is called",
        "C": "Objects can’t be passed by reference",
        "D": "Objects size depends on its class data members",
        "Answer": "D",
        "Explanation": "Objects can be passed by reference. Objects can be passed by value also. If object of a class is not created, we can’t use members of that class",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which of the following is incorrect?                  ",
        "A": " class student{ }s;",
        "B": "class student{ }; student s;",
        "C": "class student{ }s[];",
        "D": "class student{ }; student s[5];",
        "Answer": "C",
        "Explanation": "The array must be specified with a size. You can’t declare object array, or any other linear array without specifying its size. It’s a mandatory field.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "The object can’t be:                            ",
        "A": "Passed by reference",
        "B": "Passed by value",
        "C": "Passed by copy",
        "D": "Passed as function",
        "Answer": "D",
        "Explanation": "Object can’t be passed as function as it is an instance of some class, it’s not a function. Object can be passed by reference, value or copy. There is no term defined as pass as function for objects.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "What is size of the object of following class (64 bit system)?                           ",
        "A": "20",
        "B": "22",
        "C": "24",
        "D": "28",
        "Answer": "C",
        "Explanation": "The size of any object of student class will be of size 4+20=24, because static members are not really considered as property of a single object. So static variables size will not be added.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "How members of an object are accessed?",
        "A": "Using dot operator/period symbol",
        "B": "Using scope resolution operator",
        "C": "Using member names directly",
        "D": "Using pointer only",
        "Answer": "A",
        "Explanation": "Using dot operator after the name of object we can access its members. It is not necessary to use the pointers. We can’t use the names directly because it may be used outside the class.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "If a local class is defined in a function, which of the following is true for an object of that class? ",
        "A": "Object is accessible outside the function",
        "B": "Object can be declared inside any other function",
        "C": "Object can be used to call other class members",
        "D": "Object can be used/accessed/declared locally in that function.",
        "Answer": "D",
        "Explanation": "For an object which belongs to a local class, it is mandatory to declare and use the object within the function because the class is accessible locally within the class only.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which among the following is wrong?                           ",
        "A": "class student{ }; student s;",
        "B": "abstract class student{ }; student s;",
        "C": "abstract class student{ }s[50000000];",
        "D": "abstract class student{ }; class toppers: public student{ }; topper t;",
        "Answer": "B",
        "Explanation": "We can never create instance of an abstract class. Abstract classes doesn’t have constructors and hence when an instance is created there is no facility to initialize its members. Option d is correct because topper class is inheriting the base abstract class student, and hence topper class object can be created easily.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Object declared in main() function:                           ",
        "A": "Can be used by any other function",
        "B": "Can be used by main() function of any other program",
        "C": "Can’t be used by any other function",
        "D": "Can be accessed using scope resolution operator",
        "Answer": "C",
        "Explanation": "The object declared in main() have local scope inside main() function only. It can’t be used outside main() function. Scope resolution operator is used to access globally declared variables/objects.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "When an object is returned___________                                         ",
        "A": "A temporary object is created to return the value",
        "B": "The same object used in function is used to return the value",
        "C": "The Object can be returned without creation of temporary object",
        "D": "Object are returned implicitly, we can’t say how it happens inside program",
        "Answer": "A",
        "Explanation": "A temporary object is created to return the value. It is created because object used in function is destroyed as soon as the function is returned. The temporary variable returns the value and then gets destroyed.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which among the following is correct?                               ",
        "A": "class student{ }s1,s2; s1.student()=s2.student();",
        "B": "class student{ }s1; class topper{ }t1; s1=t1;",
        "C": "class student{ }s1,s2; s1=s2;",
        "D": "class student{ }s1; class topper{ }t1; s1.student()=s2.topper();",
        "Answer": "C",
        "Explanation": "Only if the objects are of same class then their data can be copied from to another using assignment operator. This actually comes under operator overloading. Class constructors can’t be assigned any explicit value as in option b and d.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which among following is correct for initializing the class below?   class student{            int marks;\r\nint cgpa;\r\npublic: student(int i, int  j){\r\nmarks=I;\r\ncgpa=j\r\n",
        "A": "student s[3]={ s(394, 9); s(394, 9); s(394,9); };",
        "B": "student s[2]={ s(394,9), s(222,5) };",
        "C": "student s[2]={ s1(392,9), s2(222,5) };",
        "D": "student s[2]={ s[392,9], s2[222,5] };",
        "Answer": "B",
        "Explanation": "It is the way we can initialize the data members for an object array using parameterized constructor. We can do this to pass our own intended values to initialize the object array data.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which feature of OOP indicates code reusability?                 ",
        "A": "Encapsulation",
        "B": "Inheritance",
        "C": "Abstraction",
        "D": "Polymorphism",
        "Answer": "B",
        "Explanation": "Inheritance indicates the code reusability. Encapsulation and abstraction are meant to hide/group data into one element. Polymorphism is to indicate different tasks performed by a single entity.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "If a function can perform more than 1 type of tasks, where the function name remains same, which feature of OOP is used here?              ",
        "A": "Encapsulation",
        "B": "Inheritance",
        "C": "Polymorphism",
        "D": "Abstraction",
        "Answer": "C",
        "Explanation": "For the feature given above, the OOP feature used is Polymorphism. Example of polymorphism in real life is a kid, who can be a student, a son, a brother depending on where he is.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "If different properties and functions of a real world entity is grouped or embedded into a single element, what is it called in OOP language?                           ",
        "A": "Inheritance",
        "B": "Polymorphism",
        "C": "Abstraction",
        "D": "Encapsulation",
        "Answer": "D",
        "Explanation": "It is Encapsulation, which groups different properties and functions of a real world entity into single element. Abstraction, on other hand, is hiding of functional or exact working of codes and showing only the things which are required by the user.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which of the following is not feature of pure OOP?                         ",
        "A": "Classes must be used",
        "B": "Inheritance",
        "C": "Data may/may not be declared using object",
        "D": "Functions Overloading",
        "Answer": "C",
        "Explanation": "Data must be declared using objects. Object usage is mandatory because it in turn calls its constructors, which in turn must have a class defined. If object is not used, it is violation of pure OOP concept.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Which among the following doesn’t come under OOP concept?                      ",
        "A": "Platform independent",
        "B": " Data binding",
        "C": "Message passing",
        "D": "Data hiding",
        "Answer": "A",
        "Explanation": "Explanation: Platform independence is not feature of OOP. C++ supports OOP but it’s not a platform independent language. Platform independence depends on programming language.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which feature of OOP is indicated by the following code?     class student{  int marks;  };\r\nclass topper:public student{  int age;  topper(int age){   this.age=age;  }   };\r\n                     ",
        "A": "Inheritance",
        "B": "Polymorphism",
        "C": "Inheritance and polymorphism",
        "D": "Encapsulation and Inheritance",
        "Answer": "D",
        "Explanation": "Encapsulation is indicated by use of classes. Inheritance is shown by inheriting the student class into topper class. Polymorphism is not shown here because we have defined the constructor in topper class but that doesn’t mean that default constructor is overloaded.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which feature may be violated if we don’t use classes in a program?",
        "A": "Inheritance can’t be implemented",
        "B": "Object must be used is violated",
        "C": "Encapsulation only is violated",
        "D": "Basically all the features of OOP gets violated",
        "Answer": "D",
        "Explanation": "All the features are violated because Inheritance and Encapsulation won’t be implemented. Polymorphism and Abstraction is still possible in some cases, but the main features like data binding, object use and etc won’t be used hence use of class is must for OOP concept.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "How many basic features of OOP are required for a programming language to be purely OOP?",
        "A": "7",
        "B": "6",
        "C": "5",
        "D": "4",
        "Answer": "A",
        "Explanation": "There are 7 basic features that define whether a programing language is pure OOP or not. The 4 basic features are inheritance, polymorphism, encapsulation and abstraction. Further, one is, object use is must, secondly, message passing and lastly, Dynamic binding.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "The feature by which one object can interact with another object is:          ",
        "A": "Data transfer",
        "B": "Data Binding",
        "C": "Message Passing",
        "D": "Message reading",
        "Answer": "C",
        "Explanation": "The interaction between two object is called message passing feature. Data transfer is not feature of OOP. Also, message reading is not feature of OOP",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "___________ underlines the feature of Polymorphism in a class.",
        "A": "Nested class",
        "B": "Enclosing class",
        "C": " Inline function",
        "D": " Virtual Function",
        "Answer": "D",
        "Explanation": " Virtual Functions can be defined in any class using the keyword virtual. All the classes which inherit the class containing the virtual function, define the virtual function as required. Redefining the function on all the derived classes according to class and use represents polymorphism.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which feature in OOP is used to allocate additional function to a predefined operator in any language?            ",
        "A": "Operator Overloading",
        "B": "Function Overloading",
        "C": "Operator Overriding",
        "D": "Function Overriding",
        "Answer": "A",
        "Explanation": "The feature is operator overloading. There is not feature named operator overriding specifically. Function overloading and overriding doesn’t give addition function to any operator.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which among doesn’t illustrates polymorphism?              ",
        "A": " Function overloading",
        "B": "Function overriding",
        "C": "Operator overloading",
        "D": "Virtual function",
        "Answer": "B",
        "Explanation": "Function overriding doesn’t illustrate polymorphism because the functions are actually different and theirs scopes are different. Function and operator overloading illustrate proper polymorphism. Virtual functions show polymorphism because all the classes which inherit virtual function, define the same function in different ways.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which among the following, for a pure OOP language, is true?                     ",
        "A": "The language should follow 3 or more features of OOP",
        "B": "The language should follow at least 1 feature of OOP",
        "C": "The language must follow only 3 features of OOP",
        "D": "The language must follow all the rules of OOP",
        "Answer": "D",
        "Explanation": "The language must follow all the rules of OOP to be called a purely OOP language. Even if a single OOP feature is not followed, then it’s known to be a partially OOP language.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "OOP provides better security than POP:                 ",
        "A": "Always true for any programming language",
        "B": "May not be true with respect to all programming languages",
        "C": "It depends on type of program",
        "D": "It’s vice-versa is true",
        "Answer": "A",
        "Explanation": "It is always true as we have the facility of private and protected access specifiers. Also, only the public and global data is available globally or else program should have proper permission to access the private data.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which among the following best describes polymorphism?                   ",
        "A": "It is the ability for a message/data to be processed in more than one form",
        "B": "It is the ability for a message/data to be processed in only 1 form",
        "C": "It is the ability for many messages/data to be processed in one way",
        "D": "It is the ability for undefined message/data to be processed in at least one way",
        "Answer": "A",
        "Explanation": "It is actually the ability for a message / data to be processed in more than one form. The word polymorphism indicates many-forms. So if a single entity takes more than one form, it is known as polymorphism.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "What do you call the languages that support classes but not polymorphism?          ",
        "A": "Class based language",
        "B": "Procedure Oriented language",
        "C": "Object-based language",
        "D": "If classes are supported, polymorphism will always be supported",
        "Answer": "C",
        "Explanation": "The languages which support classes but doesn’t support polymorphism, are known as object-based languages. Polymorphism is such an important feature, that is a language doesn’t support this feature, it can’t be called as a OOP language.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which among the following is the language which supports classes but not polymorphism?    ",
        "A": "SmallTalk",
        "B": " Java",
        "C": "C++",
        "D": "Ada",
        "Answer": "D",
        "Explanation": "Ada is the language which supports the concept of classes but doesn’t support the polymorphism feature. It is an object-based programming language. Note that it’s not an OOP language.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "If same message is passed to objects of several different classes and all of those can respond in a different way, what is this feature called?            ",
        "A": "Inheritance",
        "B": "Overloading",
        "C": "Polymorphism",
        "D": "Overriding",
        "Answer": "C",
        "Explanation": "The feature defined in question defines polymorphism feature. Here the different objects are capable of responding to the same message in different ways, hence polymorphism.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which class/set of classes can illustrate polymorphism in the following code: abstract class student\r\n{\r\n   public : int marks;\r\n   calc_grade();\r\n}\r\nclass topper:public student\r\n{\r\n    public : calc_grade()\r\n    { \r\n        return 10; \r\n    }\r\n};\r\nclass average:public student\r\n{ \r\n     public : calc_grade()\r\n     {\r\n         return 20; \r\n     }\r\n};\r\nclass failed{ int marks; };\r\n",
        "A": "Only class student can show polymorphism",
        "B": "Only class student and topper together can show polymorphism",
        "C": "All class student, topper and average together can show polymorphism",
        "D": "Class failed should also inherit class student for this code to work for polymorphism",
        "Answer": "C",
        "Explanation": "Since Student class is abstract class and class topper and average are inheriting student, class topper and average must define the function named calc_grade(); in abstract class. Since both the definition are different in those classes, calc_grade() will work in different way for same input from different objects. Hence it shows polymorphism.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which type of function among the following shows polymorphism?               ",
        "A": "Inline function",
        "B": "Virtual function",
        "C": "Undefined functions",
        "D": "Class member functions",
        "Answer": "B",
        "Explanation": "Only virtual functions among these can show polymorphism. Class member functions can show polymorphism too but we should be sure that the same function is being overloaded or is a function of abstract class or something like this, since we are not sure about all these, we can’t say whether it can show polymorphism or not.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "In case of using abstract class or function overloading, which function is supposed to be called first?                                                                                     ",
        "A": "Local function",
        "B": "Function with highest priority in compiler",
        "C": "Global function",
        "D": "Function with lowest priority because it might have been halted since long time, because of low priority",
        "Answer": "B",
        "Explanation": "Explanation: Function with highest priority is called. Here, it’s not about the thread scheduling in CPU, but it focuses on whether the function in local scope is present or not, or if scope resolution is used in some way, or if the function matches the argument signature. So all these things define which function has the highest priority to be called in runtime. Local function could be one of the answer but we can’t say if someone have used pointer to another function or same function name",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which among the following can’t be used for polymorphism?                  ",
        "A": "Static member functions",
        "B": "Member functions overloading",
        "C": "Predefined operator overloading",
        "D": "Constructor overloading",
        "Answer": "A",
        "Explanation": "Static member functions are not property of any object. Hence it can’t be considered for overloading/overriding. For polymorphism, function must be property of object, not only of class.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "What is output of the following program?     class student\r\n{ \r\n    public : int marks; \r\n void disp() \r\n { \r\n  cout<<”its base class”\r\n };\r\n class topper:public student\r\n {\r\n  public : \r\n  void disp()\r\n  { \r\n   cout<<”Its derived class”; \r\n  }\r\n }\r\n void main() { student s; topper t;\r\n s.disp();\r\n t.disp();\r\n}\r\n",
        "A": "Its base classIts derived class",
        "B": "Its base class Its derived class",
        "C": "Its derived classIts base class",
        "D": "Its derived class Its base class",
        "Answer": "A",
        "Explanation": "You need to focus on how the output is going to be shown, no space will be given after first message from base class. And then the message from derived class will be printed. Function disp() in base class overrides the function of base class being derived.advertisement",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which among the following can show polymorphism?                                 ",
        "A": "Overloading ||",
        "B": "Overloading +=",
        "C": "Overloading <<",
        "D": "Overloading &&",
        "Answer": "D",
        "Explanation": "Only insertion operator can be overloaded among all the given options. And the polymorphism can be illustrated here only if any of these is applicable of being overloaded. Overloading is type of polymorphism.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Find the output of the program:   class education\r\n{ \r\n char name[10];\r\n public : disp()\r\n { \r\n  cout<<”Its education system”;\r\n }\r\n class school:public education\r\n {\r\n  public: void dsip()\r\n  { \r\n   cout<<”Its school education system”;\r\n  }\r\n    };\r\n void main()\r\n {\r\n                school s;\r\n                s.disp();\r\n }\r\n}\r\n                 ",
        "A": "Its school education system",
        "B": "Its education system",
        "C": "Its school education systemIts education system",
        "D": "Its education systemIts school education system",
        "Answer": "A",
        "Explanation": "Notice that the function name in derived class is different from the function name in base class. Hence when we call the disp() function, base class function is executed. No polymorphism is used here.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which problem may arise if we use abstract class functions for polymorphism?                      ",
        "A": "All classes are converted as abstract class",
        "B": "Derived class must be of abstract type",
        "C": "All the derived classes must implement the undefined functions",
        "D": "Derived classes can’t redefine the function",
        "Answer": "C",
        "Explanation": "The undefined functions must be defined is a problem, because one may need to implement few undefined functions from abstract class, but he will have to define each of the functions declared in abstract class. Being useless task, it is a problem sometimes.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which among the following is not true for polymorphism?             ",
        "A": "It is feature of OOP",
        "B": "Ease in readability of program",
        "C": "Helps in redefining the same functionality",
        "D": "Increases overhead of function definition always",
        "Answer": "D",
        "Explanation": "It never increases function definition overhead, one way or another if you don’t use polymorphism, you will use the definition in some other way, so it actually helps to write efficient codes.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "If 2 classes derive one base class and redefine a function of base class, also overload some operators inside class body. Among these two things of function and operator overloading, where is polymorphism used?                             ",
        "A": "Function overloading only",
        "B": "Operator overloading only",
        "C": "Both of these are using polymorphism",
        "D": "Either function overloading or operator overloading because polymorphism can be applied only once in a program",
        "Answer": "D",
        "Explanation": "Both of them are using polymorphism. It is not a necessary that polymorphism can be used only once in a program, it can be used anywhere, any number of times in a single program",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which among the following best describes encapsulation?                  ",
        "A": "It is a way of combining various data members into a single unit",
        "B": "It is a way of combining various member functions into a single unit",
        "C": "It is a way of combining various data members and member functions into a single unit which can operate on any data",
        "D": "It is a way of combining various data members and member functions that operate on those data members into a single unit",
        "Answer": "D",
        "Explanation": "It is a way of combining both data members and member functions, which operate on those data members, into a single unit. We call it a class in OOP generally. This feature have helped us modify the structures used in C language to be upgraded into class in C++ and other languages.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "If data members are private, what can we do to access them from the class object?                     ",
        "A": "Create public member functions to access those data members",
        "B": "Create private member functions to access those data members",
        "C": "Create protected member functions to access those data members",
        "D": "Private data members can never be accessed from outside the class",
        "Answer": "A",
        "Explanation": "We can define public member functions to access those private data members and get their value for use or alteration. They can’t be accessed directly but is possible to be access using member functions. This is done to ensure that the private data doesn’t get modified accidentally.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "While using encapsulation, which among the following is possible?                    ",
        "A": "Code modification can be additional overhead",
        "B": "Data member’s data type can be changed without changing any other code",
        "C": "Data member’s type can’t be changed, or whole code have to be changed",
        "D": "Member functions can be used to change the data type of data members",
        "Answer": "B",
        "Explanation": "Data member’s data type can be changed without changing any further code. All the members using that data can continue in the same way without any modification. Member functions can never change the data type of same class data members.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Which feature can be implemented using encapsulation?                        ",
        "A": "Inheritance",
        "B": "Abstraction",
        "C": "Polymorphism",
        "D": "Overloading",
        "Answer": "B",
        "Explanation": "Data abstraction can be achieved by using encapsulation. We can hide the operation and structure of actual program from the user and can show only required information by the user",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Find which of the following uses encapsulation?                                   ",
        "A": "void main(){ int a; void fun( int a=10; cout<<a); fun(); ",
        "B": "class student{ int a; public: int b;};",
        "C": "class student{int a; public: void disp(){ cout<<a;} };",
        "D": "struct topper{ char name[10]; public : int marks; }",
        "Answer": "C",
        "Explanation": "It is the class which uses both the data members and member functions being declared inside a single unit. Only data members can be there in structures also. And the encapsulation can only be illustrated if some data/operations are associated within class.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Encapsulation helps in writing ___________ classes in java                      ",
        "A": "Mutable",
        "B": "Abstract",
        "C": "Wrapper",
        "D": "Immutable",
        "Answer": "D",
        "Explanation": "Immutable classes are used for caching purpose generally. And it can be created by making the class as final and making all its members private.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which among the following should be encapsulated?                         ",
        "A": "The data which is prone to change is near future",
        "B": "The data prone to change in long terms",
        "C": "The data which is intended to be changed",
        "D": "The data which belongs to some other class",
        "Answer": "A",
        "Explanation": "The data prone to change in near future is usually encapsulated so that it doesn’t get changed accidentally. We encapsulate the data to hide the critical working of program from outside world.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "How can Encapsulation be achieved?                     ",
        "A": "Using Access Specifiers",
        "B": "Using only private members",
        "C": "Using inheritance",
        "D": "Using Abstraction",
        "Answer": "A",
        "Explanation": "Using access specifiers we can achieve encapsulation. Using this we can in turn implement data abstraction. It’s not necessary that we only use private access.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Which among the following violates the principle of encapsulation almost always?",
        "A": "Local variables",
        "B": "Global variables",
        "C": "Public variables",
        "D": "Array variables",
        "Answer": "B",
        "Explanation": "Global variables almost always violates the principles of encapsulation. Encapsulation says the data should be accessed only by required set of elements. But global variable is accessible everywhere, also it is most prone to changes. It doesn’t hide the internal working of program.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which among the following would destroy the encapsulation mechanism if it was allowed in programming?                               ",
        "A": "Using access declaration for private members of base class",
        "B": "Using access declaration for public members of base class",
        "C": "Using access declaration for local variable of main() function",
        "D": "Using access declaration for global variables",
        "Answer": "A",
        "Explanation": "If using access declaration for private members of base class was allowed in programming, it would have destroyed whole concept of encapsulation. As if it was possible, any class which gets inherited privately, would have been able to inherit the private members of base class, and hence could access each and every member of base class.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Consider the following code and select the correct option:   advertisement  class student\r\n{  \r\n int marks;\r\n public : int* fun()\r\n { \r\n  return &marks; \r\n }\r\n};\r\nmain()\r\n{\r\nstudent s;\r\nint *ptr=c.fun();\r\nreturn 0;\r\n}\r\n              ",
        "A": "This code is good to go",
        "B": "This code may result in undesirable conditions",
        "C": "This code will generate error",
        "D": "This code violates encapsulation",
        "Answer": "D",
        "Explanation": "This code violates the encapsulation. By this code we can get the address of the private member of the class, hence we can change the value of private member, which is against the rules.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Consider the code and select the wrong choice:  class hero\r\n{ \r\n char name[10];\r\n public : void disp()\r\n { \r\n  cout<<name;\r\n }\r\n};\r\n",
        "A": "This maintains encapsulation",
        "B": "This code doesn’t maintain encapsulation",
        "C": "This code is vulnerable",
        "D": "This code gives error",
        "Answer": "A",
        "Explanation": "This code maintains encapsulation. Here the private member is kept private. Outside code can’t access the private members of class. Only objects of this class will be able to access the public member function at maximum.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Using encapsulation data security is ___________                     ",
        "A": "Not ensured",
        "B": "Ensured to some extent",
        "C": "Purely ensured",
        "D": "Very low",
        "Answer": "B",
        "Explanation": "The encapsulation can only ensure the data security to some extent. If pointer and addresses are misused, it may violate encapsulation. Use of global variables also makes the program vulnerable, hence we can’t say that encapsulation gives pure security.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Which among the following best defines abstraction?               ",
        "A": "Hiding the implementation",
        "B": "Showing the important data",
        "C": "Hiding the important data",
        "D": "Hiding the implementation and showing only the features",
        "Answer": "D",
        "Explanation": "It includes hiding the implementation part and showing only the required data and features to the user. It is done to hide the implementation complexity and details from the user. And to provide a good interface in programming.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Hiding the implementation complexity can:                            ",
        "A": ") Make the programming easy",
        "B": "Make the programming complex",
        "C": "Provide more number of features",
        "D": "Provide better features",
        "Answer": "D",
        "Explanation": "It can make the programming easy. The programming need not know how the inbuilt functions are working but can use those complex functions directly in the program. It doesn’t provide more number of features or better features.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Class is _________ abstraction                                             ",
        "A": "Object",
        "B": "Logical",
        "C": "Real",
        "D": "Hypothetical",
        "Answer": "B",
        "Explanation": "Class is logical abstraction because it provides a logical structure for all of its objects. It gives an overview of the features of an object.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Object is ________ abstraction                             ",
        "A": "Object",
        "B": "Logical",
        "C": "Real",
        "D": "Hypothetical",
        "Answer": "B",
        "Explanation": "Object is real abstraction because it actually contains those features of class. It is the implementation of overview given by class. Hence the class is logical abstraction and its object is real.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Abstraction gives higher degree of ________                                                  ",
        "A": "Class usage",
        "B": " Program complexity",
        "C": "Idealized interface",
        "D": "Unstable interface",
        "Answer": "C",
        "Explanation": "It is to idealize the interface. In this way the programmer can use the programming features more efficiently and can code better. It can’t increase the program complexity, as the feature itself is made to hide it.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Abstraction can apply to:                                        ",
        "A": "Control and data",
        "B": "Only data",
        "C": "Only control",
        "D": "Classes",
        "Answer": "A",
        "Explanation": "Abstraction applies to both. Control abstraction involves use of subroutines and control flow abstraction. Data abstraction involves handling pieces of data in meaningful ways",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Which among the following can be viewed as combination of abstraction of data and code.            ",
        "A": "Class",
        "B": " Object",
        "C": "Inheritance",
        "D": "Interfaces",
        "Answer": "D",
        "Explanation": "Object can be viewed as abstraction of data and code. It uses data members and their functioning as data abstraction. Code abstraction as use of object of inbuilt class.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Abstraction principle includes___________                               ",
        "A": "Use abstraction at its minimum",
        "B": "Use abstraction to avoid longer codes",
        "C": "Use abstraction whenever possible to avoid duplication",
        "D": "Use abstraction whenever possible to achieve OOP",
        "Answer": "C",
        "Explanation": "Abstraction principle includes use of abstraction to avoid duplication (usually of code). It this way the program doesn’t contain any redundant functions and make the program efficient.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Encapsulation and abstraction differ as:                               ",
        "A": "Binding and Hiding respectively",
        "B": "Hiding and Binding respectively",
        "C": "Can be used any way",
        "D": "Hiding and hiding respectively",
        "Answer": "A",
        "Explanation": "Abstraction is hiding the complex code. For example we directly use cout object in C++ but we don’t know how is it actually implemented. Encapsulation is data binding, as in, we try to combine the similar type of data and functions together.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "In terms of stream and files________                                       ",
        "A": "Abstraction is called a stream and device is called a file",
        "B": "Abstraction is called a file and device is called a stream",
        "C": "Abstraction can be called both file and stream",
        "D": "Abstraction can’t be defined in terms of files and stream",
        "Answer": "A",
        "Explanation": " Abstraction is called stream to provide a level of complexity hiding, for how the files operations are actually done. Actual devices are called file because in one way or another, those can be considered as single entity and there is nothing hidden.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "If two classes combine some private data members and provides public member functions to access and manipulate those data members. Where is abstraction used?                         ",
        "A": "Using private access specifier for data members",
        "B": "Using class concept with both data members and member functions",
        "C": "Using public member functions to access and manipulate the data members",
        "D": "Data is not sufficient to decide what is being used",
        "Answer": "C",
        "Explanation": " It is the concept of hiding program complexity and actual working in background. Hence use of public member functions illustrates abstraction here.advertisement",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "A phone is made up of many components like motherboard, camera, sensors and etc. If the processor represents all the functioning of phone, display shows the display only, and the phone is represented as a whole. Which among the following have highest level of abstraction?",
        "A": "Motherboard",
        "B": "Display",
        "C": "Camera",
        "D": "Phone",
        "Answer": "D",
        "Explanation": "Phone as a whole have the highest level of abstraction. This is because the phone being a single unit represents the whole system. Whereas motherboard, display and camera are its components.",
        "Difficulty": "3",
        "StID": "1"
    },
    {
        "Questions": "Which among the following is not a level of abstraction:                        ",
        "A": "Logical level",
        "B": "Physical level",
        "C": "View level",
        "D": "External level",
        "Answer": "D",
        "Explanation": "Abstraction is generally divided into 3 different levels, namely, logical, physical and view level. External level is not defined in terms of abstraction.",
        "Difficulty": "2",
        "StID": "1"
    },
    {
        "Questions": "Using higher degree of abstraction __________   ",
        "A": "May get unsafe",
        "B": "May reduce readability",
        "C": " Can be safer",
        "D": "Can increase vulnerability",
        "Answer": "C",
        "Explanation": "It will make the code safer. One may think it reduces the readability, but the fact is, it actually helps us understand the code better. We don’t have to read the complex code which is of no use in understanding the program.",
        "Difficulty": "1",
        "StID": "1"
    },
    {
        "Questions": "Which among the following is called first, automatically, whenever an object is created? ",
        "A": "Class",
        "B": "Constructor",
        "C": "New",
        "D": " Trigger",
        "Answer": "B",
        "Explanation": "Constructors are the member functions which are called automatically whenever an object is created. It is a mandatory functions to be called for an object to be created as this helps in initializing the object to a legal initial value for the class.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "Which among the following is not a necessary condition for constructors?                         ",
        "A": "Its name must be same as that of class",
        "B": "It must not have any return type",
        "C": "It must contain a definition body",
        "D": "It can contains arguments",
        "Answer": "C",
        "Explanation": "Constructors are predefined implicitly, even if the programmer doesn’t define any of them. Even if the programmer declares a constructor, it’s not necessary that it must contain some definition.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "Which among the following is correct?                          ",
        "A": "class student{ public: int student(){} };",
        "B": "class student{ public: void student (){} };",
        "C": "class student{ public: student{}{} };",
        "D": "class student{ public: student(){} };",
        "Answer": "D",
        "Explanation": "The constructors must not have any return type. Also, the body may or may not contain any body. Defining default constructor is optional, if you are not using any other constructor.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "In which access should a constructor be defined, so that object of the class can be created in any function?                             ",
        "A": "Public",
        "B": "Protected",
        "C": "Private",
        "D": "Any access specifier will work",
        "Answer": "A",
        "Explanation": "Constructor function should be available to all the parts of program where the object is to be created. Hence it is advised to define it in public access, so that any other function is able to create objects.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "How many types of constructors are available for use in general (with respect to parameters)?",
        "A": "2",
        "B": "3",
        "C": "4",
        "D": "5",
        "Answer": "A",
        "Explanation": "Two types of constructors are defined generally, namely, default constructor and parameterized constructor. Default constructor is not necessary to be defined always.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "If a programmer defines a class and defines a default value parameterized constructor inside it.He has not defined any default constructor. And then he try to create the object without passing arguments, which among the following will be correct?",
        "A": "It will not create the object (as parameterized constructor is used)",
        "B": "It will create the object (as the default arguments are passed )",
        "C": "It will not create the object ( as the default constructor is not defined )",
        "D": "It will create the object ( as at least some constructor is defined )",
        "Answer": "B",
        "Explanation": "It will create the object without any problem, because the default arguments use the default value if no value is passed. Hence it is equal to default constructor with zero parameters. But it will not create the object if signature doesn’t match.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "If class C inherits class B. And B has inherited class A. Then while creating the object of class C, what will be the sequence of constructors getting called?                ",
        "A": "Constructor of C then B, finally of A",
        "B": "Constructor of A then C, finally of B",
        "C": "Constructor of C then A, finally B",
        "D": "Constructor of A then B, finally C",
        "Answer": "D",
        "Explanation": "While creating the object of class C, its constructor would be called by default. But, if the class is inheriting some other class, firstly the parent class constructor will be called so that all the data is initialized that is being inherited.",
        "Difficulty": "3",
        "StID": "2"
    },
    {
        "Questions": "In multiple inheritance, if class C inherits two classes A and B as follows, which class constructor will be called first: class A{ };\r\nclass B{ };\r\nclass C: public A, public B{  };\r\n                                                                ",
        "A": "A()",
        "B": "B()",
        "C": "C()",
        "D": "Can’t be determined",
        "Answer": "A",
        "Explanation": "Constructor of class A will be called first. This is because the constructors in multiple inheritance are called in the sequence in which they are written to be inherited. Here A is written first, hence it is called first.",
        "Difficulty": "3",
        "StID": "2"
    },
    {
        "Questions": "Which among the following is true for copy constructor?                         ",
        "A": "The argument object is passed by reference",
        "B": "It can be defined with zero arguments",
        "C": "Used when an object is passed by value to a function",
        "D": "Used when a function returns an object",
        "Answer": "B",
        "Explanation": "It can’t be defined with zero number of arguments. This is because to copy one object to another, the object must be mentioned so that compiler can take values from that object.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "If the object is passed by value to a copy constructor:                           ",
        "A": "Only public members will be accessible to be copied",
        "B": "That will work normally",
        "C": "Compiler will give out of memory error",
        "D": "Data stored in data members won’t be accessible",
        "Answer": "C",
        "Explanation": "Compiler runs out of memory. This is because while passing the argument by value, a constructor of the object will be called. That in turn called another object constructor for values, and this goes on. This is like a constructor call to itself, and this goes on infinite times, hence it must be passed by reference, so that the constructor is not called.",
        "Difficulty": "3",
        "StID": "2"
    },
    {
        "Questions": "Which object will be created first?      class student \r\n{  \r\n    int marks;\r\n};\r\nstudent s1, s2, s3;\r\n                      ",
        "A": "s1 then s2 then s3",
        "B": "s3 then s2 then s1",
        "C": "s2 then s3 then s1",
        "D": "All are created at same time",
        "Answer": "A",
        "Explanation": "The objects are created in the sequence of how they are written. This happens because the constructors are called in the sequence of how the objects are mentioned. This is done in sequence.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "Which among the following helps to create a temporary instance?     ",
        "A": "Implicit call to a default constructor",
        "B": "Explicit call to a copy constructor",
        "C": "Implicit call to a parameterized constructor",
        "D": "Explicit call to a constructor",
        "Answer": "D",
        "Explanation": "Explicit call to a constructor can let you create temporary instance. This is because the temporary instances doesn’t have any name. Those are deleted from memory as soon as their reference is removed.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "Which among the following is correct for the class defined below? class student\r\n{\r\n int marks;\r\n public: student(){}\r\n student(int x)\r\n { \r\n  marks=x; \r\n }\r\n};\r\nmain()\r\n{\r\nstudent s1(100);\r\nstudent s2();\r\nstudent s3=100;\r\nreturn 0;\r\n      ",
        "A": "Object s3, syntax error",
        "B": "Only object s1 and s2 will be created",
        "C": "Program runs and all objects are created",
        "D": "Program will give compile time error",
        "Answer": "C",
        "Explanation": "It is a special case of constructor with only 1 argument. While calling a constructor with one argument, you are actually implicitly creating a conversion from the argument type to the type of class. Hence you can directly specify the value of that one argument with assignment operator.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "For constructor overloading, each constructor must differ in ___________ and __________",
        "A": "Number of arguments and type of arguments",
        "B": "Number of arguments and return type",
        "C": "Return type and type of arguments",
        "D": "Return type and definition",
        "Answer": "A",
        "Explanation": "Each constructor must differ in the number of arguments it accepts and the type of arguments. This actually defines the constructor signature. This helps to remove the ambiguity and define a unique constructor as required.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "How many types of constructors are available, in general, in any language?        ",
        "A": "2",
        "B": "3",
        "C": "4",
        "D": "5",
        "Answer": "B",
        "Explanation": "There are 3 types of constructors in general, namely, default constructors, parameterized constructors and copy constructors. Default one is called whenever an object is created without arguments.",
        "Difficulty": "3",
        "StID": "2"
    },
    {
        "Questions": "Choose the correct option for the following code.class student\r\n{\r\n    int marks;\r\n}\r\nstudent s1;\r\nstudent s2=2;\r\n         ",
        "A": "Object s1 should be passed with argument.",
        "B": "Object s2 should not be declared",
        "C": "Object s2 will not be created, but program runs",
        "D": "Program gives compile time error",
        "Answer": "D",
        "Explanation": "The object s2 can be assigned with one value only if a single argument constructor is defined in class, but here, it can’t be done as no constructor is defined. Hence every object must be declare or created without using arguments.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "Which constructor is called while assigning some object with another?",
        "A": "Default",
        "B": "Parameterized",
        "C": "Copy",
        "D": "Direct assignment is used",
        "Answer": "C",
        "Explanation": "Copy constructor is used while an object is assigned with another. This is mandatory since we can’t decide which member should be assigned to which member value. By using copy constructor, we can assign the values in required form",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "It’s necessary to pass object by reference in copy constructor because: ",
        "A": "Constructor is not called in pass by reference",
        "B": "Constructor is called in pass by reference only",
        "C": "It passes the address of new constructor to be created",
        "D": "It passes the address of new object to be created",
        "Answer": "A",
        "Explanation": "Object must be passed by reference to copy constructor because constructor is not called in pass by reference. Otherwise, in pass by value, a temporary object will be created which in turn will try to call its constructor that is already being used. This results in creating infinite number of objects and hence memory shortage error will be shown.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "Which specifier applies only to the constructors?           ",
        "A": "Public",
        "B": "Protected",
        "C": "Implicit",
        "D": "Explicit",
        "Answer": "D",
        "Explanation": "The keyword explicit can be used while defining the constructor only. This is used to suppress the implicit call to the constructor. It ensures that the constructors are being called with the default syntax only (i.e. only by using object and constructor name).",
        "Difficulty": "3",
        "StID": "2"
    },
    {
        "Questions": "Which among the following is true?                                       ",
        "A": "Default constructor can’t be defined by the programmer",
        "B": "Default parameters constructor isn’t equivalent to default constructor",
        "C": "Default constructor can be called explicitly",
        "D": "Default constructor is and always called implicitly only",
        "Answer": "C",
        "Explanation": "Default constructors can be called explicitly anytime. They are specifically used to allocate memory space for the object in memory, in general. It is not necessary that these should always be called implicitly.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "Which type of constructor can’t have a return type?                     ",
        "A": "Default",
        "B": "Parameterized",
        "C": "Copy",
        "D": "Constructors don’t have a return type",
        "Answer": "D",
        "Explanation": " Constructors don’t return any value. Those are special functions, whose return type is not defined, not even void. This is so because the constructors are meant to initialize the members of class and not to perform some task which can return some value to newly created object.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "Why do we use static constructors?               ",
        "A": "To initialize the static members of class",
        "B": "To initialize all the members with static value",
        "C": "To delete the static members when not required",
        "D": "To clear all the static members initialized values",
        "Answer": "A",
        "Explanation": "Static constructors help in initializing the static members of the class. This is provided because the static members are not considered to be property of the object, rather they are considered as the property of class.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "When and how many times a static constructor is called?                    ",
        "A": "Created at time of object destruction",
        "B": "Called at first time when an object is created and only one time",
        "C": "Called at first time when an object is created and called with every new object creation",
        "D": "Called whenever an object go out of scope",
        "Answer": "B",
        "Explanation": " Those are called at very first call of object creation. That is called only one time because the value of static members must be retained and continued from the time it gets created.",
        "Difficulty": "3",
        "StID": "2"
    },
    {
        "Questions": "Which among the following is true for static constructor?                    ",
        "A": "Static constructors are called with every new object",
        "B": "Static constructors are used initialize data members to zero always",
        "C": "Static constructors can’t be parameterized constructors",
        "D": "Static constructors can be used to initialize the non-static members also",
        "Answer": "C",
        "Explanation": "Static constructors can’t be parameterized constructors. Those are used to initialize the value of static members only. And that must be a definite value. Accepting arguments may make it possible that static members loses their value with every new object being created.advertisement",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "Default constructor initializes all data members as:                     ",
        "A": "All numeric member with some garbage values and string to random string",
        "B": "All numeric member with some garbage values and string to null",
        "C": "All numeric member with zero and strings to random value",
        "D": "All numeric member with zero and strings to null",
        "Answer": "D",
        "Explanation": "Default constructor, which even the programmer doesn’t define, always initialize the values as zero if numeric and null if string. This is done so as to avoid the accidental values to change the conditional statements being used and similar conditions.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "When is the static constructor called?           ",
        "A": "After the first instance is created",
        "B": "Before default constructor call of first instance",
        "C": "Before first instance is created",
        "D": "At time of creation of first instance",
        "Answer": "C",
        "Explanation": " The static constructor is called before creation of first instance of that class. This is done so that even the first instance can use the static value of the static members of the class and manipulate as required.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "If constructors of a class are defined in private access, then:                ",
        "A": "The class can’t be inherited",
        "B": "The class can be inherited",
        "C": "Instance can be created only in another class",
        "D": "Instance can be created anywhere in the program",
        "Answer": "A",
        "Explanation": "If the constructors are defined in private access, then the class can’t be inherited by other classes. This is useful when the class contains static members only. The instances can never be created.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "Which among the following is correct, based on the given code below: class student\r\n{ \r\n int marks;\r\n public : student()\r\n {  \r\n  cout<<”New student details can be added now”;\r\n }\r\n};\r\nstudent s1;\r\n                       ",
        "A": "Cout can’t be used inside the constructor",
        "B": "Constructor must contain only initializations",
        "C": "This program works fine",
        "D": "This program produces errors",
        "Answer": "C",
        "Explanation": "This program will work fine. This is because it is not mandatory that a constructor must contain only initialization only. If you want to perform a task on each instance being created, that code can be written inside the constructor.",
        "Difficulty": "3",
        "StID": "2"
    },
    {
        "Questions": "Copy constructor is a constructor which _____________",
        "A": "Creates an object by copying values from any other object of same class",
        "B": "Creates an object by copying values from first object created for that class",
        "C": "Creates an object by copying values from another object of another class",
        "D": "Creates an object by initializing it with another previously created object of same class",
        "Answer": "D",
        "Explanation": "The object that has to be copied to new object must be previously created. The new object gets initialized with the same values as that of the object mentioned for being copied. The exact copy is made with values.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "The copy constructor can be used to:                                    ",
        "A": "Initialize one object from another object of same type",
        "B": "Initialize one object from another object of different type",
        "C": "Initialize more than one object from another object of same type at a time",
        "D": "Initialize all the objects of a class to another object of another class",
        "Answer": "A",
        "Explanation": "The copy constructor has the most basic function to initialize the members of an object with same values as that of some previously created object. The object must be of same class.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "If two classes have exactly same data members and member function and only they differ by class name. Can copy constructor be used to initialize one class object with another class object?",
        "A": "Yes, possible",
        "B": "Yes, because the members are same",
        "C": "No, not possible",
        "D": "No, but possible if constructor is also same",
        "Answer": "C",
        "Explanation": "The restriction for copy constructor is that it must be used with the object of same class. Even if the classes are exactly same the constructor won’t be able to access all the members of another class. Hence we can’t use object of another class for initialization.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "The copy constructors can be used to ________               ",
        "A": "Copy an object so that it can be passed to a class",
        "B": "Copy an object so that it can be passed to a function",
        "C": "Copy an object so that it can be passed to another primitive type variable",
        "D": "Copy an object for type casting",
        "Answer": "B",
        "Explanation": "When an object is passed to a function, actually its copy is made in the function. To copy the values, copy constructor is used. Hence the object being passed and object being used in function are different.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "Which returning an object, we can use ____________               ",
        "A": "Default constructor",
        "B": "Zero argument constructor",
        "C": "Parameterized constructor",
        "D": "Copy constructor",
        "Answer": "D",
        "Explanation": "While returning an object we can use the copy constructor. When we assign the return value to another object of same class then this copy constructor will be used. And all the members will be assigned the same values as that of the object being returned.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "If programmer doesn’t define any copy constructor then _____________                  ",
        "A": "Compiler provides an implicit copy constructor",
        "B": "Compiler gives an error",
        "C": "The objects can’t be assigned with another objects",
        "D": "The program gives run time error if copying is used",
        "Answer": "A",
        "Explanation": "The compiler provides an implicit copy constructor. It is not mandatory to always create an explicit copy constructor. The values are copied using implicit constructor only.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "If a class implements some dynamic memory allocations and pointers then _____________",
        "A": "Copy constructor must be defined",
        "B": "Copy constructor must not be defined",
        "C": "Copy constructor can’t be defined",
        "D": "Copy constructor will not be used",
        "Answer": "A",
        "Explanation": "In the case where dynamic memory allocation is used, the copy constructor definition must be given. The implicit copy constructor is not capable of manipulating the dynamic memory and pointers. Explicit definition allows to manipulate the data as required.",
        "Difficulty": "3",
        "StID": "2"
    },
    {
        "Questions": "What is the syntax of copy constructor?                ",
        "A": "classname (classname &obj){ /*constructor definition*/ }",
        "B": "classname (cont classname obj){ /*constructor definition*/ }",
        "C": "classname (cont classname &obj){ /*constructor definition*/ }",
        "D": "classname (cont classname &obj){ /*constructor definition*/ }",
        "Answer": "C",
        "Explanation": "The syntax must contain the class name first, followed by the classname as type and &object within parenthesis. Then comes the constructor body. The definition can be given as per requirements.",
        "Difficulty": "3",
        "StID": "2"
    },
    {
        "Questions": "Object being passed to a copy constructor ___________             ",
        "A": "Must be passed by reference",
        "B": "Must be passed by value",
        "C": "Must be passed with integer type",
        "D": "Must not be mentioned in parameter list",
        "Answer": "A",
        "Explanation": "This is mandatory to pass the object by reference. Otherwise the object will try to create another object to copy its values, in turn a constructor will be called, and this will keep on calling itself. This will cause the compiler to give out of memory error.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "Out of memory error is given when the object _____________ to the copy constructor.",
        "A": "Is passed with & symbol",
        "B": "Is passed by reference",
        "C": "Is passed as",
        "D": "Is not passed by reference",
        "Answer": "D",
        "Explanation": "All the options given, directly or indirectly indicate that the object is being passed by reference. And if object is not passed by reference then the out of memory error is produced. Due to infinite constructor call of itself.",
        "Difficulty": "3",
        "StID": "2"
    },
    {
        "Questions": "Copy constructor will be called whenever the compiler __________         ",
        "A": "Generates implicit code",
        "B": "Generates member function calls",
        "C": "Generates temporary object",
        "D": "Generates object operations",
        "Answer": "C",
        "Explanation": "Whenever the compiler creates a temporary object, copy constructor is used to copy the values from existing object to the temporary object.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "The deep copy is possible only with the help of __________    ",
        "A": "Implicit copy constructor",
        "B": "User defined copy constructor",
        "C": "Parameterized constructor",
        "D": "Default constructor",
        "Answer": "B",
        "Explanation": "While using explicit copy constructor, the pointers of copied object point to the intended memory location. This is assured since the programmers themselves manipulate the addresses.advertisement",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "Can a copy constructor be made private?             ",
        "A": "Yes, always",
        "B": "Yes, if no other constructor is defined",
        "C": "No, never",
        "D": "No, private members can’t be accessed",
        "Answer": "A",
        "Explanation": "The copy constructor can be defined private. If we make it private then the objects of the class can’t be copied. It can be used when a class used dynamic memory allocation.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "The arguments to a copy constructor _____________                ",
        "A": "Must be const",
        "B": "Must not be cosnt",
        "C": "Must be integer type",
        "D": "Must be static",
        "Answer": "A",
        "Explanation": "The object should not be modified in the copy constructor. Because the object itself is being copied. When the object is returned from a function, the object must be a constant otherwise the compiler creates a temporary object which can die anytime.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "Which among the following best describes constructor overloading?    ",
        "A": "Defining one constructor in each class of a program",
        "B": "Defining more than one constructor in single class",
        "C": "Defining more than one constructor in single class with different signature",
        "D": "Defining destructor with each constructor",
        "Answer": "C",
        "Explanation": "If more than one constructors are defined in a class with same signature, then that results in error. The signatures must be different. So that the constructors can be differentiated.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "Can constructors be overloaded in derived class?                          ",
        "A": "Yes, always",
        "B": "Yes, if derived class has no constructor",
        "C": "No, programmer can’t do it",
        "D": "No, never",
        "Answer": "D",
        "Explanation": "The constructor must be having the same name as that of a class. Hence a constructor of one class can’t even be defined in another class. Since the constructors can’t be defined in derived class, it can’t be overloaded too, in derived class.",
        "Difficulty": "3",
        "StID": "2"
    },
    {
        "Questions": "Does constructor overloading include different return types for constructors to be overloaded?",
        "A": "Yes, if return types are different, signature becomes different",
        "B": "Yes, because return types can differentiate two functions",
        "C": "No, return type can’t differentiate two functions",
        "D": "No, constructors doesn’t have any return type",
        "Answer": "D",
        "Explanation": "The constructors doesn’t have any return type. When we can’t have return type of a constructor, overloading based on the return type is not possible. Hence only parameters can be different.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "Which among the following is possible way to overload constructor?        ",
        "A": "Define default constructor, 1 parameter constructor and 2 parameter constructor",
        "B": "Define default constructor, zero argument constructor and 1 parameter constructor",
        "C": "Define default constructor, and 2 other parameterized constructors with same signature",
        "D": "Define 2 default constructors",
        "Answer": "A",
        "Explanation": "All the constructors defined in a class must have different signature in order to be overloaded. Here one default and other parameterized constructors are used, wherein one is of only one parameter and other accepts two. Hence overloading is possible.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "Which constructor will be called from the object created in the code below?     class A\r\n{ \r\n int i;\r\n A()\r\n { \r\n  i=0; cout&lt;&lt;i; \r\n }\r\n A(int x=0)\r\n { \r\n  i=x;  cout&lt;&lt;I;  \r\n }\r\n};\r\nA obj1;\r\n    ",
        "A": "Default constructor",
        "B": "Parameterized constructor",
        "C": "Compile time error",
        "D": "Run time error",
        "Answer": "C",
        "Explanation": "When a default constructor is defined and another constructor with 1 default value argument is defined, creating object without parameter will create ambiguity for the compiler. The compiler won’t be able to decide which constructor should be called, hence compile time error.",
        "Difficulty": "3",
        "StID": "2"
    },
    {
        "Questions": "Which among the following is false for a constructor?                          ",
        "A": "Constructors doesn’t have a return value",
        "B": "Constructors are always user defined",
        "C": "Constructors are overloaded with different signature",
        "D": "Constructors may or may not have any arguments being accepted",
        "Answer": "B",
        "Explanation": "The constructors are not always user defined. The construct will be provided implicitly from the compiler if the used doesn’t defined any constructor. The implicit constructor makes all the string values null and allocates memory space for each data member.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "When is the constructor called for an object?                ",
        "A": "As soon as overloading is required",
        "B": "As soon as class is derived",
        "C": "As soon as class is created",
        "D": "As soon as object is created",
        "Answer": "D",
        "Explanation": "The function this() can be used to call the default constructor from inside any other constructor. This helps to further reuse the code and not to write the redundant data in all the constructors.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "Which among the following function can be used to call default constructor implicitly in java?   ",
        "A": "this()",
        "B": "that()",
        "C": "super()",
        "D": "sub()",
        "Answer": "A",
        "Explanation": "The function this() can be used to call the default constructor from inside any other constructor. This helps to further reuse the code and not to write the redundant data in all the constructors.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "Why do we use constructor overloading?",
        "A": "To use different types of constructors",
        "B": "Because it’s a feature provided",
        "C": "To initialize the object in different ways",
        "D": "To differentiate one constructor from another",
        "Answer": "C",
        "Explanation": "The constructors are overloaded to initialize the objects of a class in different ways. This allows us to initialize the object with either default values or used given values. If data members are not initialized then program may give unexpected results.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "If programmer have defined parameterized constructor only, then __________________    ",
        "A": "Default constructor will not be created by the compiler implicitly",
        "B": "Default constructor will be created by the compiler implicitly",
        "C": "Default constructor will not be created but called at runtime",
        "D": "Compile time error",
        "Answer": "A",
        "Explanation": " When the programmer doesn’t specify any default constructor and only defines some parameterized constructor. The compiler doesn’t provide any default constructor implicitly. This is because it is assumed that the programmer will create the objects only with constructors.advertisement",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "Which among the following is not valid in java?                                   ",
        "A": "Constructor overloading",
        "B": "Recursive constructor call",
        "C": "Default value constructors",
        "D": "String argument constructor",
        "Answer": "B",
        "Explanation": "Java doesn’t provide the feature to recursively call the constructor. This is to eliminate the out of memory error in some cases that arises unexpectedly. That is an predefined condition for constructors in java.",
        "Difficulty": "1",
        "StID": "2"
    },
    {
        "Questions": "Which constructor will be called from the object obj2 in the following program?    class A\r\n{\r\n int i;\r\n A()\r\n {  \r\n  i=0;  \r\n }\r\n A(int x)\r\n {  \r\n  i=x+1;  \r\n }\r\n A(int y, int x)\r\n {  \r\n  i=x+y;  \r\n }\r\n};\r\nA obj1(10);\r\nA obj2(10,20);\r\nA obj3;\r\n                  ",
        "A": "A(int x)",
        "B": "A(int y)",
        "C": "A(int y, int x)",
        "D": "A(int y; int x)",
        "Answer": "C",
        "Explanation": "The two argument constructor will be called as we are passing 2 arguments to the object while creation. The arguments will be passed together and hence compiler resolves that two argument constructor have to be called.",
        "Difficulty": "3",
        "StID": "2"
    },
    {
        "Questions": "What is we only create an object but don’t call any constructor for it in java?               ",
        "A": "Implicit constructor will be called",
        "B": "Object is initialized to some null values",
        "C": "Object is not created",
        "D": "Object is created but points to null",
        "Answer": "D",
        "Explanation": "The object becomes a reference object which can be initialized will another object. Then this object will indirectly become another name of the object being assigned. If not assigned, it simply points to null address.",
        "Difficulty": "2",
        "StID": "2"
    },
    {
        "Questions": "Which among the following is false?                        ",
        "A": "Constructor can’t be overloaded in Kotlin",
        "B": "Constructors can’t be called recursively in java",
        "C": "Constructors can be overloaded in C++",
        "D": "Constructors overloading depends on different signatures",
        "Answer": "A",
        "Explanation": "Kotlin language allows constructor overloading. This is a basic feature for the constructors. The constructor overloading allows the object to be initialized according to the user.",
        "Difficulty": "3",
        "StID": "2"
    },
    {
        "Questions": "Which is correct syntax?            ",
        "A": " classname objectname= new() integer;",
        "B": "classname objectname= new classname;",
        "C": "classname objectname= new classname();",
        "D": "classname objectname= new() classname();",
        "Answer": "C",
        "Explanation": "The syntax for object creating in java with calling a constructor for is it is as in option c. The syntax must contain the classname followed by the object name. The keyword new must be used and then the constructor call with or without the parameters as required.\r\n",
        "Difficulty": "3",
        "StID": "2"
    },
    {
        "Questions": "How many types of access specifiers are provided in OOP (C++)?             ",
        "A": "1",
        "B": "2",
        "C": "3",
        "D": "4",
        "Answer": "C",
        "Explanation": "Only 3 types of access specifiers are available. Namely, private, protected and public. All these three can be used according to the need of security of members.",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "Which among the following can be used together in a single class?             ",
        "A": "void main(){ int a; void fun( int a=10; cout<<a); fun(); ",
        "B": "Private and Protected together",
        "C": "Private and Public together",
        "D": "All three together",
        "Answer": "D",
        "Explanation": "All the classes can use any of the specifiers as needed. There is no restriction on how many of them can be used together.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "Which among the following can restrict class members to get inherited?",
        "A": "Private",
        "B": "Protected",
        "C": "Public",
        "D": "All three",
        "Answer": "A",
        "Explanation": "Private members of a class can’t be inherited. These members can only be accessible from members of its own class only. It is used to secure the data.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "Which access specifier is used when no access specifier is used with a member of class (java)?",
        "A": "Private",
        "B": "Default",
        "C": "Protected",
        "D": "Public",
        "Answer": "B",
        "Explanation": "Default access is used if the programmer doesn’t specify the specifier. This acts in similar way as that of private. But since nothing is specified we call it default access.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "Which specifier allows a programmer to make the private members which can be inherited? ",
        "A": "Private",
        "B": "Default",
        "C": "Protected",
        "D": "Protected and default",
        "Answer": "C",
        "Explanation": "Protected access is used to make the members private. But those members can be inherited. This gives both security and code reuse capability to a program.",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "Which among the following is false?             ",
        "A": "Private members can be accessed using friend functions",
        "B": "Member functions can be made private",
        "C": "Default members can’t be inherited",
        "D": "Public members are accessible from other classes also",
        "Answer": "C",
        "Explanation": "The default members can be inherited. Provided that they are in same package. It works in a little different way from private access specifier.",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "If a class has all the private members, which specifier will be used for its implicit constructor?",
        "A": "Private",
        "B": "Virtual function",
        "C": "Protected",
        "D": "Default",
        "Answer": "D",
        "Explanation": "The implicit constructor will always be public. Otherwise the class wouldn’t be able to have instances. In turn, no objects will be created and the class can only be used for inheritance.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "If class A has add() function with protected access, and few other members in public . Then class B inherits class A privately. Will the user will not be able to call _________ from object of class B.",
        "A": "Any function of class A",
        "B": "The add() function of class A",
        "C": "Any member of class A",
        "D": "Private, protected and public members of class A",
        "Answer": "D",
        "Explanation": "Class B object will not be able to call any of the private, protected and public members of class A. It is not only about the function add(), but all the members of class A will become private members of class B.",
        "Difficulty": "3",
        "StID": "3"
    },
    {
        "Questions": "Which access specifier should be used in a class where the instances can’t be created?   ",
        "A": "Private default constructor",
        "B": "All private constructors",
        "C": "Only default constructor to be public",
        "D": "Only default constructor to be protected",
        "Answer": "B",
        "Explanation": "All the constructors must be made private. This will restrict the instance of class to be made anywhere in the program. Since the constructors are private, no instance will be able to call them and hence won’t be allocated with any memory space.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "On which specifier’s data, does the size of a class’s object depend?                     ",
        "A": "All the data members are added",
        "B": "Only private members are added",
        "C": "Only public members are added",
        "D": "Only default data members are added",
        "Answer": "A",
        "Explanation": "All the data members are counted to calculate the size of an object of a class. The data member access specifier doesn’t play any role here. Hence all the data size will be added.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "If class B inherits class A privately. And class B has a friend function. Will the friend function be able to access the private member of class A?                      ",
        "A": "Yes, because friend function can access all the members",
        "B": "Yes, because friend function is of class B",
        "C": ") No, because friend function can only access private members of friend class",
        "D": "No, because friend function can access private member of class A also",
        "Answer": "D",
        "Explanation": "The friend function of class B will not be able to access private members of class A. Since B is inheriting class A privately, the members will become private in class B. But private members of class A won’t be inherited at all. Hence it won’t be accessible.",
        "Difficulty": "3",
        "StID": "3"
    },
    {
        "Questions": "If an abstract class has all the private members, then _________                      ",
        "A": "No class will be able to implement members of abstract class",
        "B": "Only single inheritance class can implement its members",
        "C": "Only other enclosing classes will be able to implement those members",
        "D": "No class will be able to access those members but can implement.",
        "Answer": "A",
        "Explanation": "The classes which inherit the abstract class, won’t be able to implement the members of abstract class. The private members will not be inherited. This will restrict the subclasses to implement those members.\r\nadvertisement\r\n",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "Which access specifier should be used so that all the parent class members can be inherited and accessed from outside the class?                            ",
        "A": "Private",
        "B": "Default or public",
        "C": "Protected or private",
        "D": "Public",
        "Answer": "D",
        "Explanation": "\r\nExplanation: All the members must be of public access. So that the members can be inherited easily. Also, the members will be available from outside the class.\r\n",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "Which access specifier is usually used for data members of a class?                              ",
        "A": "Private",
        "B": "Default",
        "C": "Protected",
        "D": "Public",
        "Answer": "A",
        "Explanation": "All the data members should be made private to ensure the highest security of data. In special cases we can use public or protected access, but it is advised to keep the data members private always.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "Which specifier should be used for member functions of a class?                  ",
        "A": "Private",
        "B": "Default",
        "C": "Protected",
        "D": "Public",
        "Answer": "D",
        "Explanation": "It is always advised that the member functions should be kept public so that those functions can be used from out of the class. This is usually done to ensure that the features provided by the class can be used at its maximum.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "If a function has to be called only by using other member functions of the class, what should be the access specifier used for that function?                       ",
        "A": "Private",
        "B": "Protected",
        "C": "Public",
        "D": "Default",
        "Answer": "A",
        "Explanation": "The function should be made private. In this way, the function will be available to be called only from the class member functions. Hence the function will be secure from outside world.",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "Which among the following is correct for the code given below? class student\r\n{  \r\n private: student()\r\n {  \r\n }\r\n public : student( int x) \r\n { \r\n  marks =x; \r\n }\r\n};\r\n     ",
        "A": "The object can never be created",
        "B": "The object can be created without parameters",
        "C": "Only the object with only 1 parameter can be created",
        "D": "Only the object with some parameters can be created",
        "Answer": "C",
        "Explanation": "For creating object without parameters, the default constructor must be defined in public access. But here, only parameterized constructor is public, hence the objects being created with only one parameter will only be allowed.",
        "Difficulty": "3",
        "StID": "3"
    },
    {
        "Questions": "Which among the following is true for the code given below?    class A\r\n{\r\n private : int marks; char name[20];\r\n public :\r\n A(int x=100)\r\n { \r\n  marks=x;  \r\n }\r\n};\r\n            ",
        "A": "Objects can be created with one parameter or without parameter",
        "B": "Object can be created only with one parameter",
        "C": "Object can be created with more than one parameter",
        "D": "Objects can be create only without parameter",
        "Answer": "A",
        "Explanation": "The constructor here has a default argument constructor. Hence we can pass one parameter, but that is optional. If an object is created without parameter, the default value will be used in the constructor definition.",
        "Difficulty": "3",
        "StID": "3"
    },
    {
        "Questions": "Which among the following is correct to call a private member from outside the class? ",
        "A": "object.memberfunction( parameters );",
        "B": "object->memberfunction( parameters );",
        "C": "object->memberfunction( parameteres); or object.memberfunction( parameters );",
        "D": "Not possible",
        "Answer": "D",
        "Explanation": "The private member function will not be accessible from outside the class. Hence any syntax will not work to access the private members. If you have the address of the member, may be you can access those members, but that is totally different case and concept.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "If private members has to be accessed directly from outside the class but the access specifier must not be changed, what should be done?                ",
        "A": "Specifier must be changed",
        "B": "Friend function should be used",
        "C": "Other public members should be used",
        "D": "It is not possible",
        "Answer": "B",
        "Explanation": "For calling the function directly, we can’t use another function because that will be indirect call. Using friend function, we can access the private members directly.",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "Which access specifier is/are most secure during inheritance?                ",
        "A": "Private",
        "B": "Default",
        "C": "Protected",
        "D": "Private and default",
        "Answer": "A",
        "Explanation": "The private members are most secure in inheritance. The default members can still be in inherited in special cases, but the private members can’t be accessed in any case.",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "Choose the correct option for the code given below  \r\nclass A{ static int c=0; public: A(){ c++; } };          \r\n",
        "A": "Constructor will make c=1 for each object created",
        "B": "Constructor will make c=0 for each object created",
        "C": "Constructor will keep number of objects created",
        "D": "Constructor will just initialize c=0 then increment by 1",
        "Answer": "C",
        "Explanation": "The constructor is using a static member to keep the count of the number of objects created. This is done because the variable c is static and hence the value will be common for all the objects created.",
        "Difficulty": "3",
        "StID": "3"
    },
    {
        "Questions": "Which option is false for the following code?  class A\r\n{\r\n private : int sum(int x, int y)\r\n { \r\n  return x+y; \r\n }\r\n public: A()\r\n {  \r\n }\r\n A(int x, int y)\r\n { \r\n  cout&lt;&lt;sum(x,y);  \r\n }\r\n};\r\n",
        "A": "Constructor can be created with zero argument",
        "B": "Constructor prints sum, if two parameters are passed with object creation",
        "C": "Constructor will give error if float values are passed",
        "D": "Constructor will take 0 as default value of parameters if not passed",
        "Answer": "D",
        "Explanation": "Constructor is not having any default arguments hence no default value will be given to any parameters. Only integer values must be passed to the constructor if we need the sum as output, otherwise if float values are passed, type mismatch will be shown as error.",
        "Difficulty": "3",
        "StID": "3"
    },
    {
        "Questions": "Which member will never be used from the following class?  class A()\r\n{ \r\n int marks; char name[20];\r\n public : A()\r\n { \r\n  marks=100; \r\n }\r\n void disp()\r\n { \r\n  cout&lt;&lt;”Marks= ”&lt'&lt;marks;\r\n  cout&lt;&lt;”Student”;\r\n }\r\n};\r\n",
        "A": "name variable will never be used",
        "B": "marks variable will never be used",
        "C": "constructor will never be used",
        "D": "disp() function will never be used",
        "Answer": "A",
        "Explanation": "Variable name will never be used. It is a private member. None other than class members can access name, also, neither the constructor nor the disp() function are accessing the variable name. Hence it will never be accessible.",
        "Difficulty": "3",
        "StID": "3"
    },
    {
        "Questions": "Which among the following is true?                 ",
        "A": "Private member functions can’t be overloaded",
        "B": "Private member functions can be overridden",
        "C": "Private member functions can’t be overloaded with a public member",
        "D": "Private member function can’t be overridden",
        "Answer": "D",
        "Explanation": "The private member functions can be overloaded but they can’t be overridden. This is because, overriding means a function with same name in derived class, gets more priority when called from object of derived class. Here, the member function is private so there is no way that it can be overridden.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "Which data member in following code will be used whenever an object is created?       Class A\r\n{ \r\n   int x; int y; int z;\r\n   public : A()\r\n   { \r\n      y=100; x=100*y; \r\n   }\r\n};\r\n",
        "A": "x will be used",
        "B": "y will be used",
        "C": "z will be used",
        "D": "All will be used",
        "Answer": "C",
        "Explanation": "Whenever an object will be created, the constructor will be called. Inside constructor we are using the data members x and y. Hence these two will always be used with each object creation.",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "Which member can be considered most secure in the code below? class A()\r\n{\r\n int a;\r\n private : int b;\r\n protected : int c;\r\n public : int d;\r\n};\r\n   ",
        "A": "a",
        "B": "b",
        "C": "c",
        "D": "d",
        "Answer": "B",
        "Explanation": "The default variables can be inherited in some special cases but the public members can never be inherited. Hence the most secure data member in the class is b",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "Which among the following is correct for the code given below?  class A\r\n{\r\n private : A()\r\n { \r\n }\r\n public : A(int x)\r\n {  \r\n }\r\n};\r\nA a;\r\nA b(100);\r\n",
        "A": "Program will give compile time error",
        "B": "Program will run fine",
        "C": "Program will give runtime error",
        "D": "Program will give logical error",
        "Answer": "A",
        "Explanation": "The program will be giving a compile time error as the default constructor is private in class. And, the logical errors are usually runtime so we can’t say that the program will give logical error. The program will not run.",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "Which among the following is correct?        ",
        "A": "Private specifier must be used before public specifier",
        "B": "Private specifier must be used before protected specifier",
        "C": "Private specifier must be used first",
        "D": "Private specifier can be used anywhere in class",
        "Answer": "D",
        "Explanation": "The private specifier can be used anywhere in the class as required. It is not a rule to mention the private members first and then others. It is just followed to write first for better readability.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "Which among the following best describes the protected specifier?  ",
        "A": " Members are most secure and can’t be used outside class",
        "B": "Members are secure but can be used outside the class",
        "C": "Members are secure as private, but can be inherited",
        "D": "Members are secure like private, but can’t be inherited",
        "Answer": "C",
        "Explanation": "The members which are made protected, are most secure if inheritance is not used. But, this facility is provided to keep those members private and with that, they can be inherited by other classes. This is done to make the code more flexible.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "If a constructor is defined in protected access, then.                        ",
        "A": "It’s instance can be created inside the subclasses",
        "B": "It’s instance can be created anywhere in the program",
        "C": "It’s instance can be created inside the subclasses and main() function",
        "D": "It’s instance can be created inside the parent class only",
        "Answer": "A",
        "Explanation": "The instances will be allowed to be created only inside the sub classes. This is because the protected members will be inherited and hence the constructor too. This will allow the subclasses to call the constructor whenever an object is created.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "For the following code, choose the correct option: class A\r\n{  \r\n int marks;\r\n protected : A()\r\n { \r\n  marks=100; \r\n }\r\n public : A( int x)\r\n { \r\n  marks=x;  \r\n }\r\n};\r\n",
        "A": "The instances can be created only in subclasses",
        "B": "The instances can be created only in main() function",
        "C": "The instances can be created only in parent class",
        "D": "The instances can be created anywhere in the program",
        "Answer": "D",
        "Explanation": "The instances can be created anywhere in the program. The only restriction will be on which constructor will have to be called. The instances with zero arguments will be allowed to be created only inside the subclasses, but the instances with one argument can be created anywhere in the program.",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "If the protected members are to be made accessible only to the nearest subclass and no further subclasses, which access specifier should be used in inheritance?         ",
        "A": "The sub class should inherit the parent class privately",
        "B": "The sub class should inherit the parent class as protected",
        "C": "The sub class should inherit the parent class as public",
        "D": "The sub class can use any access modifier",
        "Answer": "A",
        "Explanation": "The sub class should inherit the parent class privately",
        "Difficulty": "3",
        "StID": "3"
    },
    {
        "Questions": "What will be the output of following code (all header files and required things are included)? class A\r\n{\r\n int marks;\r\n protected : A(int x)\r\n { \r\n  marks=x; \r\n }\r\n public : A()\r\n { \r\n  marks=100; \r\n }\r\n}\r\nclass B\r\n{\r\n A a;\r\n A b=100;\r\n};\r\nmain()\r\n{\r\n A a, b=100;\r\n B c;\r\n}\r\n",
        "A": "Program runs fine",
        "B": "Program gives runtime error",
        "C": "Program gives compile time error",
        "D": "Program gives logical error",
        "Answer": "C",
        "Explanation": "The objects being created with assignment value are allowed, if the constructor accepts only 1 argument. But main() function will not be able to create the object here with assignment, as the constructor which accepts one argument is in protected mode in the class",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "Which among the following is true for the given code below class A\r\n{\r\n protected : int marks;\r\n public : \r\n A()\r\n { \r\n  marks=100; \r\n }\r\n disp()\r\n { \r\n  cout&lt;&lt;”marks=”&lt;&lt;marks; \r\n }\r\n};\r\nclass B: protected A\r\n{\r\n};\r\nB b;\r\nb.disp();\r\n",
        "A": "Object b can’t access disp() function",
        "B": "Object b can access disp() function inside its body",
        "C": "Object b can’t access members of class A",
        "D": "Program runs fine",
        "Answer": "A",
        "Explanation": "The object of class B can’t access the members of A outside the class. This is because the class is being inherited in protected access, so all the members will become protected in subclass B.",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "Protected members differ from default members as_______            ",
        "A": "Protected members can be accessed outside package using inheritance, but default can’t",
        "B": "Default members can be accessed outside package using inheritance, but protected can’t",
        "C": "Protected members are allowed for inheritance but Default members are not allowed",
        "D": "Both are same",
        "Answer": "A",
        "Explanation": "The protected members are allowed in the same package but can also be accessed in other packages using inheritance. But the default members can never be accessible in other packages.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "If all the members are defined in protected specifier then ( Constructors not considered )",
        "A": "Instance of class can’t be created",
        "B": "Instance of class can be created anywhere",
        "C": "Instance of class can be created only in subclasses",
        "D": "Instance of class can be created only in main() function",
        "Answer": "B",
        "Explanation": "The instances can be created anywhere in the program. This is because the constructors are not considered among the members defined in protected mode. Hence the default implicit constructor will be used whenever an object is created.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "Which among the following is correct for the code given class A\r\n{\r\n    private: int marks;\r\n    A()\r\n    { \r\n    }\r\n    Public : disp()\r\n    { \r\n          cout&lt;&lt; marks; \r\n     }\r\n};\r\nclass B: public A\r\n{\r\n}\r\nB b;\r\n",
        "A": "Instance of B will not be created",
        "B": "Instance of B will be created",
        "C": "Program gives compile time error",
        "D": "Program gives runtime error",
        "Answer": "A",
        "Explanation": "Instance of B will not be created. When you try to create instance of B, First the constructor of parent class will be called, but the parent class constructor is private, hence it won’t be able to initialize and allocate memory for parent class members. In turn, the object of B will not be created. advertisement",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "If protected inheritance is used then _____                             ",
        "A": "Public members become public in subclass",
        "B": "Protected members become public in subclass",
        "C": "Protected members become protected in subclass",
        "D": "Protected and Public members become protected in subclass",
        "Answer": "D",
        "Explanation": "The protected and public members of the parent class will become the protected members in subclass. This is predefined rule of inheritance. The reason behind is to maintain the level of security in subclass too.",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "If protected members are to be accessed from outside the class then__________  ",
        "A": "Members must be inherited publicly in subclass",
        "B": "Members must accessed using class pointers",
        "C": "Members must be accessed as usual",
        "D": "Members must be made public",
        "Answer": "D",
        "Explanation": "The members must be made public, otherwise it is not possible. In every case, the protected members will act as private members if it’s about access specifier. It will only be inherited, that too will lead to make those members protected again, in subclasses.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "Which among the following can use protected access specifier?  ",
        "A": "Members which may be used in other packages",
        "B": "Members which have to be secure and should be used by other packages/subclass",
        "C": "Members which have to be accessed from anywhere in the program",
        "D": "Members which have to be as secure as private but can be used by main() function",
        "Answer": "B",
        "Explanation": "The members which have to be secure and might get used in other packages or subclasses can use protected access. This also allows the members to be safe from accidental modification.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "If a class have default constructor defined in private access, and one parameter constructor in protected mode, how will it be possible to create instance of object?           ",
        "A": "Define a constructor in public access with different signature",
        "B": "Directly create the object in the subclass",
        "C": "Directly create the object in main() function",
        "D": "Not possible",
        "Answer": "A",
        "Explanation": "If a new constructor is defined in public access. That will be available to whole program. Only restriction will be of the way to use it.",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "What will be the output of the program given below:   class A\r\n{\r\n Public : A(int a=0)\r\n { \r\n  cout&lt;&lt;”new A”;\r\n        }\r\n};\r\nA a;\r\nA b;\r\nA c;\r\n     ",
        "A": "new A new A new A",
        "B": "newAnewAnewA",
        "C": "new Anew Anew A",
        "D": "new A new Anew A",
        "Answer": "C",
        "Explanation": "The constructor has a default argument. Whenever the object is created, the constructor will be called and print the message in its definition. Since the argument is default valued, it is not mandatory to pass anything to the new object",
        "Difficulty": "3",
        "StID": "3"
    },
    {
        "Questions": "Which among the following is true for the code given below:     class A\r\n{\r\n int marks;\r\n public : disp()\r\n { \r\n  cout&lt;&lt;marks; \r\n }\r\n}\r\nclass B: protected A\r\n{\r\n char name[20];\r\n}\r\nA a; a.disp();\r\nB b; b.disp();",
        "A": "Only object of class A can access disp() function",
        "B": "Only object of class B can access disp() function",
        "C": "Both instances can access disp() function",
        "D": "Accessing disp() outside class is not possible",
        "Answer": "A",
        "Explanation": "The object of class A can access the disp() function. This is because the disp() function is public in definition of class A. But it can’t be accessed from instance of class B because the disp() function is protected in class B, since it was inherited as protected.",
        "Difficulty": "3",
        "StID": "3"
    },
    {
        "Questions": "If the members have to be accessed from anywhere in program and other packages also, which access specifier should be used?   ",
        "A": "Public",
        "B": "Private",
        "C": "Protected",
        "D": "Default",
        "Answer": "A",
        "Explanation": "The access specifier must be public so as to access the members outside the class and anywhere within the program without using inheritance. This is a rule, predefined for the public members.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "Which among the following have least security according to the access permissions allowed?",
        "A": "Public",
        "B": "Private",
        "C": "Protected",
        "D": "Default",
        "Answer": "A",
        "Explanation": "The public members are available to whole program. This makes the members most vulnerable to accidental changes, which may result in unwanted modification and hence unstable programming.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "Which among the following can be used for outermost class access specifier in java?",
        "A": "Private",
        "B": "Public",
        "C": "Default",
        "D": "Default or Public",
        "Answer": "D",
        "Explanation": "Either default or public access specifier must be used for outermost classes. Private can be used with inner classes. This is done so that all the members can access and use the utmost class and that program execution can be done from anywhere. Inner classes can be made private for security.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "If members of a super class are public, then________    ",
        "A": "All those will be available in subclasses",
        "B": "None of those will be available in subclasses",
        "C": "Only data members will be available in subclass",
        "D": "Only member functions will be available in subclass",
        "Answer": "A",
        "Explanation": "All the members will be available in subclasses. Though it is not guaranteed whether the members will be available in subsequent subclasses from the first subclass.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "How many public class(s) (outermost) can be there in a java program?     ",
        "A": "1",
        "B": "2",
        "C": "3",
        "D": "As required",
        "Answer": "A",
        "Explanation": "There can be only one public class in a java program. The public class name must match the name of file. And there can’t be more than one class with same name in a single program in same scope. Hence it is not possible to have more than one public class in java program.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "What is output of following code?   package pack1;\r\nclass A\r\n{\r\n public A()\r\n { \r\n  System.out.print(“object created”); \r\n }   \r\n}\r\npackage pack2;\r\nimport pack1.*;\r\nclass B\r\n{\r\n A a=new A();\r\n}",
        "A": "Output is: object created",
        "B": "Output is: object createdobject created",
        "C": "Compile time error",
        "D": "Run time error",
        "Answer": "C",
        "Explanation": "The program will give compile time error. Class A is defined with default access specifier. This directly means that class A will be available within package only. Even if the constructor is public, the object will not be created.",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "Which among the following for public specifier is false?",
        "A": "The static members can’t be public",
        "B": "The public members are available in other packages too",
        "C": "The subclasses can inherit the public members privately",
        "D": "There can be only one public class in java program",
        "Answer": "A",
        "Explanation": "The static members are not property of any object of the class. Instead, those are treated as property of class. This allows us to have public static members too.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "A class has its default constructor defined as public. Class B inherits class A privately. The class:",
        "A": "B will not be able to have instances  220",
        "B": " Only A can have instances",
        "C": "Only B can have instances",
        "D": "Both classes can have instances",
        "Answer": "D",
        "Explanation": "Class A can have instances as it has public default constructor. Class will have its own constructors defined. Hence both classes can have instances.",
        "Difficulty": "2",
        "StID": "3"
    },
    {
        "Questions": "Which specifier can be used to inherit protected members as protected in subclass but public as public in subclass?        ",
        "A": "Private",
        "B": "Default",
        "C": " Public",
        "D": "Protected",
        "Answer": "C",
        "Explanation": "The specifier that can make protected member’s protected in subclass and public member’s public in subclass, is public. This is done to maintain the security level of protected members of parent class.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "Which among the following is true for public class?     ",
        "A": "There can be more than one public class in a single program",
        "B": " Public class members can be used without using instance of class",
        "C": " Public class is available only within the package",
        "D": "Public classes can be accessed from any other class using instance",
        "Answer": "D",
        "Explanation": "The public class is a usual class. There is no special rule but the members of the class can be accessed from other classes using instance of the class. This is usually useful to define main() function.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "If a class doesn’t have public members, then________ ",
        "A": "None of its members will be able to get inherited",
        "B": "None of its instance creation will be allowed",
        "C": " None of its member function can be called outside the class",
        "D": "None of its data members will be able to get initial value",
        "Answer": "D",
        "Explanation": "According to rule of private, protected and default access specifiers, none of the members under these specifiers will be able to get invoked outside the class. We are not sure about the members of class specifically so other options doesn’t give a fixed answer.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "n multi-level inheritance(all public) , the public members of parent/superclass will ________",
        "A": "Will continue to get inherited subsequently",
        "B": "Will not be inherited after one subclass inheritance",
        "C": "Will not be available to be called outside class",
        "D": "Will not be able to allocated with any memory space",
        "Answer": "A",
        "Explanation": "The public inheritance makes the public members of base class, public in derived classes. This can be used when the same feature have to be redefined with each new class inheriting the base class.",
        "Difficulty": "3",
        "StID": "3"
    },
    {
        "Questions": "Which specifier allows to secure the public members of base class in inherited classes?",
        "A": "Private",
        "B": "Protected",
        "C": "Public",
        "D": "Private and Protected",
        "Answer": "D",
        "Explanation": "Both the private and protected specifiers can make the public members of base class more secure. This is useful if we stop using the parent class members and use the classes which inherited the parent class, so as to secure data better.",
        "Difficulty": "1",
        "StID": "3"
    },
    {
        "Questions": "What is the term used to indicate the variable and constants of a class?",
        "A": "Data members",
        "B": "Variables of class",
        "C": "Data characters",
        "D": "Constants",
        "Answer": "A",
        "Explanation": " The variables inside a class are termed data members of the class. It is not a mandatory rule but variables are used to refer usual variables used in functions or globally. The term is given because the values stored in those variables represent some kind of data related to class.",
        "Difficulty": "2",
        "StID": "4"
    },
    {
        "Questions": "Data members ________________ (C++)",
        "A": "Can be initialized with declaration in classes",
        "B": "Can be initialized only with help of constructors",
        "C": "Can be initialized either in declaration or by constructor",
        "D": "Can be initialized either in declaration or by constructor",
        "Answer": "B",
        "Explanation": "The data members are not property of class, those are property of the instances of the class. And the memory for the data members are not reserved until a constructor is called. Hence we use constructors for their initialization after the memory is reserved.",
        "Difficulty": "3",
        "StID": "4"
    },
    {
        "Questions": "Which among the following is true for data members?           ",
        "A": "Private data members can be initialized with declaration in class",
        "B": "Static members are initialized in constructors",
        "C": "Protected data members can be initialized in class directly",
        "D": "Static data members are defined outside class, not in constructor",
        "Answer": "D",
        "Explanation": "Static members are not property of instances of classes. Those are shared by all the object of classes. Hence those are defined outside the constructor, so as to make them common for all the objects.",
        "Difficulty": "3",
        "StID": "4"
    },
    {
        "Questions": "What should be done for data member to be of user defined structure type?   ",
        "A": "The structure must have been defined before class.",
        "B": "The structure must have been defined after the class definition",
        "C": "The structure must be predefined",
        "D": "The structure type data members can’t be used",
        "Answer": "A",
        "Explanation": "The structure must have been defined prior to its use. If the structure is not defined, then the memory space will not be allocated for its members. This leads to undefined use of new data types.",
        "Difficulty": "3",
        "StID": "4"
    },
    {
        "Questions": "How many data members can a class contain?    ",
        "A": "27",
        "B": "255",
        "C": "1024",
        "D": "As many as required",
        "Answer": "D",
        "Explanation": "Any class can have as many data members as required. The only restriction that may arise is when there is not enough memory space. This gives flexibility to define a class with best properties possible.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "How to access data members of a class? ",
        "A": "Dot operator",
        "B": "Arrow operator",
        "C": "Dot or arrow as required",
        "D": "Dot, arrow or direct call",
        "Answer": "C",
        "Explanation": "The data members can never be called directly. Dot operator is used to access the members with help of object of class. Arrow is usually used if pointers are used.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "To create a pointer to a private data member of a class, outside the class, which among the following is correct?",
        "A": "Return the address of the private data member using a member function",
        "B": "Access the private member using a pointer outside class",
        "C": "Declare the member as pointer inside the class",
        "D": "Not possible to create pointer to a private member",
        "Answer": "A",
        "Explanation": "We can call a public member function and return the address of any private data member. Though the pointer being returned must be defined inside class itself. And the returned address can be stored in a pointer.",
        "Difficulty": "3",
        "StID": "4"
    },
    {
        "Questions": "Which among the following is true for use of setter() and getter() function?    ",
        "A": "Considered best for manipulating data values",
        "B": "Considered the only proper way to manipulate the values",
        "C": "Considered specially for private members manipulation",
        "D": "Considered a red flag, and not recommended for large scale use",
        "Answer": "D",
        "Explanation": "This concept of getter and setter functions is not acceptable if used too much. This is considered to be inappropriate in OOP perspective. Though it is commonly used, it doesn’t work according to OOP concepts at some higher level of understanding.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "What is the output of following code?   nt n=10;  // global\r\nclass A()\r\n{\r\n private : int n;\r\n public : int m;\r\n A()\r\n { \r\n  n=100; m=50;\r\n }\r\nvoid disp()\r\n{\r\n cout<<”n”<<m<<n;\r\n};",
        "A": "1050100",
        "B": "1005010",
        "C": "n5010",
        "D": "n50100",
        "Answer": "D",
        "Explanation": " In cout we have specified n as a string to be printed. And m is a variable so its value gets printed. And global variable will not be used since local variable have more preference.",
        "Difficulty": "2",
        "StID": "4"
    },
    {
        "Questions": "The static member functions can only use ________    ",
        "A": "Static data members",
        "B": "Private data members",
        "C": "Protected data members",
        "D": "Constant data members",
        "Answer": "D",
        "Explanation": "The static member functions can only access static data members. This is because the static member function can’t work with the properties that change object to object. It is mandatory that only the common properties of all the objects be used. And only static data members are common to all as those are property of class.advertisement",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "What is the keyword used to make data members have same value? ",
        "A": " static",
        "B": "const",
        "C": "double",
        "D": " abstract",
        "Answer": "B",
        "Explanation": "The keyword const can be used anywhere to make the variable have same value all the time. This restriction is made to use the same value whenever required. Also, this can restrict accidental changes.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "Which data members can be inherited but are private to a class?  ",
        "A": "Private",
        "B": "Protected",
        "C": "Protected and Static",
        "D": "Privately inherited",
        "Answer": "B",
        "Explanation": " Static members inheritance also depends on the type of specifier they have. Only the protected members can be inherited but remain private to class. If static members are defined in private access, they won’t be allowed for inheritance.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "Which among the following is not allowed for data member declaration?                ",
        "A": "int a;",
        "B": "static int a;",
        "C": " abstract a;",
        "D": " Boolean a;",
        "Answer": "D",
        "Explanation": "The abstract keyword in declaration of data members is not allowed. This is because the abstract keyword features can’t be used with the data members of the class. We can have all other syntax given, but not abstract.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "Which among the following best describes member functions? ",
        "A": "Functions which are defined within the class",
        "B": "Functions belonging a class",
        "C": "Functions in public access of a class",
        "D": "Functions which are private to class",
        "Answer": "B",
        "Explanation": "We can’t say that only functions which are defined inside class are member functions. There can be some inherited functions. Though they doesn’t belong to the class but are property of the objects once inheritance is used. So the nearest definition is functions belonging a class.",
        "Difficulty": "3",
        "StID": "4"
    },
    {
        "Questions": "How many types of member functions are generally there in C++?     ",
        "A": "2",
        "B": "3",
        "C": "4",
        "D": "5",
        "Answer": "D",
        "Explanation": "There are 5 types of member functions that are generally provided in C++. Namely, simple, static, const, inline and friend member functions. Member functions are specific to classes.",
        "Difficulty": "3",
        "StID": "4"
    },
    {
        "Questions": "How can a static member function be called in main function?          ",
        "A": " Using dot operator",
        "B": " Using arrow operator",
        "C": "Using dot or arrow operator",
        "D": "Using dot, arrow or using scope resolution operator with class name",
        "Answer": "D",
        "Explanation": "The member functions can be called using only the dot operator or the arrow operator. But the static members can be called using directly the class name followed by the scope resolution",
        "Difficulty": "3",
        "StID": "4"
    },
    {
        "Questions": "What are inline member functions?",
        "A": "Member functions which can be called without object",
        "B": "Member functions whose definition is expanded in place of its call",
        "C": "Member functions whose definition is faster than simple function",
        "D": "Member function which is defined in single line",
        "Answer": "B",
        "Explanation": "The member functions whose definition is expanded at the call, and no jump to function and return happened, are termed as inline functions. This is used to make the program faster and more efficient.",
        "Difficulty": "2",
        "StID": "4"
    },
    {
        "Questions": "What happens if non static members are used in static member function?             ",
        "A": "Compile time error",
        "B": " Runtime error",
        "C": "Executes fine",
        "D": "Executes if that member function is not used",
        "Answer": "A",
        "Explanation": "There must be specific memory space allocated for the data members before the static member functions uses them. But the space is not reserved if object is not declared. Hence only if static members are not used, it leads to compile time error.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "Static member functions _____________    ",
        "A": "Contains “this” pointer for data members",
        "B": "Contains “this” pointer if used for member functions",
        "C": "Doesn’t contain “this” pointer",
        "D": "Doesn’t contain “this” pointer if member functions are referred",
        "Answer": "C",
        "Explanation": "The static member functions doesn’t contain “this” pointer. Static member functions can’t be defined as const or volatile also. These are restrictions on static member functions.",
        "Difficulty": "3",
        "StID": "4"
    },
    {
        "Questions": "How to access members of the class inside a member function?        ",
        "A": "Using this pointer only",
        "B": "Using dot operator",
        "C": "Using arrow operator",
        "D": "Used directly or with this pointer",
        "Answer": "D",
        "Explanation": "The members of a class can be used directly inside a member function. We can use this pointer when there is a conflict between data members of class and arguments/local function variable names.",
        "Difficulty": "3",
        "StID": "4"
    },
    {
        "Questions": "For overloading “( )”, “[ ]” or “->” operators, a class __________ ",
        "A": "Must use static member functions",
        "B": "Must use non-static member functions",
        "C": "Must be non-static member and should not be friend of class",
        "D": "Must use static member function or a friend member function",
        "Answer": "C",
        "Explanation": "Must use static member function or a friend member function",
        "Difficulty": "3",
        "StID": "4"
    },
    {
        "Questions": "If a virtual member function is defined, ___________    ",
        "A": "It should not contain any body and defined by subclasses",
        "B": "It must contain body and overridden by subclasses",
        "C": "It must contain body and be overloaded",
        "D": "It must not contain any body and should not be derived",
        "Answer": "A",
        "Explanation": "The virtual functions are defined using virtual keyword. These are made in order to make all the classes to define them as the class gets inherited. Increases code understanding.",
        "Difficulty": "2",
        "StID": "4"
    },
    {
        "Questions": "Member functions of a generic class are _____________",
        "A": "Not generic",
        "B": "Automatically generic",
        "C": " To be made generic explicitly",
        "D": "Given default type as double",
        "Answer": "B",
        "Explanation": "When generic type is used in a class, the functions are automatically generic. This is so because the functions would use the same type as defined to make the class generic. The functions will get to know the type of data as soon as the generic class is used. It’s inbuilt feature.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "Member function of a class can ____________               ",
        "A": "Access all the members of the class",
        "B": "Access only Public members of the class",
        "C": "Access only the private members of the class",
        "D": "Access subclass members",
        "Answer": "A",
        "Explanation": "The member functions has access to all the members of the class. Whenever data",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "Which among the following is proper syntax for class given below?           class A\r\n{ \r\n int a,b;\r\n public : void disp();\r\n}",
        "A": "void disp::A(){ }",
        "B": " void A::disp(){ }",
        "C": "void A:disp() { cout<<a<<b ; }",
        "D": "void disp:A(){ cout<<a<<b; }",
        "Answer": "B",
        "Explanation": "The syntax in option b is correct. We use scope resolution to represent the member function of a class and to write its definition. It is not necessary for a function to have anything in its definition.",
        "Difficulty": "2",
        "StID": "4"
    },
    {
        "Questions": "A member function can _______________ of the same class  ",
        "A": "Call other member functions",
        "B": "Call only private member functions",
        "C": "Call only static member functions",
        "D": "Call only const member functions",
        "Answer": "A",
        "Explanation": " We can call one function inside another function to access some data of class. A public member function can be used to call a private member function which directly manipulates the private data of class.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "Which member function doesn’t require any return type?   ",
        "A": "Static",
        "B": "Constructor",
        "C": "Const",
        "D": "Constructor and destructor",
        "Answer": "D",
        "Explanation": "All the member functions work same as normal functions with syntax. But the constructor and destructor are also considered as member functions of a class, and they never have any data type.",
        "Difficulty": "2",
        "StID": "4"
    },
    {
        "Questions": "Which among the following is not possible for member function? ",
        "A": "Access protected members of parent class",
        "B": "Definition without return type",
        "C": "Access public members of subclass",
        "D": "Access static members of class",
        "Answer": "C",
        "Explanation": "A member function of a class can only have the access to the members of its own class and parent classes if inheritance used. Otherwise a member function can never access the members of a subclass. Accessing static members of a class is possible by normal and static member functions.",
        "Difficulty": "3",
        "StID": "4"
    },
    {
        "Questions": "What are local classes?       ",
        "A": "Classes declared inside a package",
        "B": "Classes declared inside a function",
        "C": "Classes declared inside a class",
        "D": "Classes declared inside structure",
        "Answer": "B",
        "Explanation": "The classes declared inside a package are available to all the functions and classes, hence can’t be called local. This is somewhat similar concept that we use to denote variables of a function. The classes declared inside functions will be local to them.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "All member functions of a local class must be ___________   ",
        "A": "Defined outside class body",
        "B": "Defined outside the function definition",
        "C": "Defined inside the class body",
        "D": "Defined at starting of program",
        "Answer": "C",
        "Explanation": "There is a restriction on where the member functions of the local class should be define. Those must be defined inside the class body only. This is to reduce the ambiguity and complexity of program.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "Can local class members access/use the general local variables (except static, abstract etc.) of the function in which it is defined?",
        "A": " Yes, it can access with arrow operator",
        "B": " No, it can’t access with dot operator",
        "C": " Yes, it can access using dot operator",
        "D": "No, it can’t access In anyway",
        "Answer": "D",
        "Explanation": "The local variables of the functions are not available to the member functions of the class. This is done to reduce the ambiguity in variables and their access rules.",
        "Difficulty": "2",
        "StID": "4"
    },
    {
        "Questions": "Which type of data can a local class access from the function in which it is defined?",
        "A": "Static and extern",
        "B": "Abstract and static",
        "C": "Void and extern",
        "D": "Const and static",
        "Answer": "A",
        "Explanation": "The local classes have this feature to access the static and extern variables of the function in which those are defined. This feature is available since these type of data are common to the program and is created only one time. Run time creation and destruction of these variables is not done. The only restriction that may apply is those members must be constants.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "Can static variables be declared inside a local class?         ",
        "A": " Yes, with public access specifier",
        "B": "Yes, anywhere as required",
        "C": " No, not possible in private access specifier",
        "D": "No, not possible anyway",
        "Answer": "D",
        "Explanation": "No, the static variables can’t be declared inside a local class. This is because each time the function is called, all the variables get created again and are destroyed as soon as the function is returned. This would have been possible id the static variable was of function.",
        "Difficulty": "3",
        "StID": "4"
    },
    {
        "Questions": "All the member functions of local classes are __________ by default.",
        "A": "Static",
        "B": "Inline",
        "C": "Abstract",
        "D": "Virtual",
        "Answer": "C",
        "Explanation": "All the members are defined inside the class body. And when the member functions are defined inside the class body, they are made inline by default. If the definition is too complex, those are made normal functions.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "Which language can use inheritance with local classes?       ",
        "A": "Kotlin",
        "B": "Java",
        "C": "SmallTalk",
        "D": "SAP ABAP",
        "Answer": "D",
        "Explanation": " Other language might support inheritance with local classes but those doesn’t provide all the proper features of inheritance. Language SAP ABAP provides a way to implement inheritance with local classes efficiently.",
        "Difficulty": "3",
        "StID": "4"
    },
    {
        "Questions": "How many local classes can be defined inside a single function? ",
        "A": "Only 1",
        "B": "Only 3",
        "C": "Only 5",
        "D": "As many as required",
        "Answer": "D",
        "Explanation": "The local classes can be defined as required. There is no restriction on the number of local classes that can be defined inside a function. But all those classes must follow the rules and restrictions.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "All the data members of local class must be ___________         ",
        "A": "Defined with declaration",
        "B": "Defined in constructor",
        "C": "Declared and defined in constructor",
        "D": "Declared using a member function",
        "Answer": "B",
        "Explanation": "The data members follow same rules as of simple classes. Hence the data members must be declared first. Then their definition must be given using the constructors.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "Can two different functions have local class with same name?   ",
        "A": "Yes, since local",
        "B": "No, names must be different",
        "C": "No, scope doesn’t work here",
        "D": "No, ambiguity arises",
        "Answer": "A",
        "Explanation": "The local classes can have same name if they belong to different functions. The classes would be local to those specific functions and hence can have same name. This is same as that of local variables concept.  advertisement",
        "Difficulty": "2",
        "StID": "4"
    },
    {
        "Questions": "What is the scope of local class?      ",
        "A": "Within the class only",
        "B": "Within the function",
        "C": "Within the program",
        "D": "One time creation and live till end of program",
        "Answer": "B",
        "Explanation": "The scope of a local class is limited only within the function definition. The function can use the class as usual as local variables. The class gets destroyed as soon as the function is returned.",
        "Difficulty": "2",
        "StID": "4"
    },
    {
        "Questions": "Can a function, other than the enclosing function of local class, access the class members?",
        "A": " Yes, using object",
        "B": "Yes, using direct call",
        "C": "Yes, using pointer",
        "D": "No, can’t access",
        "Answer": "D",
        "Explanation": "The local classes are local to the specific enclosing function. Other functions can’t access the class. Even if the pointers are used, the class must be alive when the pointer is used. But this will not happen if the enclosing function is returned.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "Which among the following is main advantage of using local classes? ",
        "A": "Make program more efficient",
        "B": "Makes program execution faster",
        "C": "Helps to add extra functionality to a function",
        "D": "Helps to add more members to a function",
        "Answer": "C",
        "Explanation": " The closest answer is to add more functionalities to a function or to make some specific functions to be generic. Adding more members to a function can be done directly but to add some special functionality that are encapsulated, can be done using local classes.",
        "Difficulty": "3",
        "StID": "4"
    },
    {
        "Questions": "Which among the following best describes a nested class? ",
        "A": "Class inside a class",
        "B": "Class inside a function",
        "C": "Class inside a package",
        "D": "Class inside a structure",
        "Answer": "A",
        "Explanation": "If a class is defined inside another class, the inner class is termed as nested class. The inner class is local to the enclosing class. Scope matters a lot here.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "Which feature of OOP reduces the use of nested classes?      ",
        "A": "Encapsulation",
        "B": "Inheritance",
        "C": " Binding",
        "D": "Abstraction",
        "Answer": "B",
        "Explanation": "Using inheritance we can have the security of the class being inherited. The subclass can access the members of parent class. And have more feature than a nested class being used.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "How many categories are nested classes divided into?   ",
        "A": "2",
        "B": "3",
        "C": "4",
        "D": "5",
        "Answer": "A",
        "Explanation": "The nested classes are divided into two main categories. Namely, Static and non-static. The categories define how the classes can be used inside another class.",
        "Difficulty": "2",
        "StID": "4"
    },
    {
        "Questions": "Non-static nested classes have access to _____________ from enclosing class.",
        "A": "Private members",
        "B": "Protected members",
        "C": "Public members",
        "D": "All the members",
        "Answer": "D",
        "Explanation": "The non-static nested class can access all the members of the enclosing class. All the data members and member functions can be accessed from the nested class. Even if the members are private, they can be accessed.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "Static nested classes doesn’t have access to _________________ from enclosing class",
        "A": "Private members",
        "B": "Protected members",
        "C": "Public members",
        "D": "All the members",
        "Answer": "D",
        "Explanation": "The static nested class doesn’t have access to any other members of the enclosing class. This is a rule that is made to ensure that only the data which can be common to all the object is being accessed by the static nested class.",
        "Difficulty": "3",
        "StID": "4"
    },
    {
        "Questions": "The nested class can be declared ___________________    ",
        "A": "Public",
        "B": "Private",
        "C": "Protected",
        "D": "Public, Protected, Private or Package private",
        "Answer": "D",
        "Explanation": "The nested class can be declared with any specifier, unlike the outer classes which can only be declared public or package private. This is a flexibility given for the nested class being a member of enclosing class.",
        "Difficulty": "1",
        "StID": "4"
    },
    {
        "Questions": "Use of nested class ____________ encapsulation.   ",
        "A": "Increases",
        "B": "Decreases",
        "C": "Doesn’t affect",
        "D": "Slightly decreases",
        "Answer": "A",
        "Explanation": "The use of nested class increases encapsulation as the inner class is getting even more grouped into the enclosing class. Firstly the class encapsulate the data, having nested classes can increase the encapsulation even further.",
        "Difficulty": "2",
        "StID": "4"
    },
    {
        "Questions": "Which among the following is correct advantage/disadvantage of nested classes?  ",
        "A": "Makes the code more complex",
        "B": "Makes the code unreadable",
        "C": "Makes the code efficient and readable",
        "D": "Makes the code multithreaded",
        "Answer": "C",
        "Explanation": "The use of nested classes make the code more streamed towards a single concept. This allows to group the most similar and related classes together and makes it even more efficient and readable.",
        "Difficulty": "2",
        "StID": "4"
    },
    {
        "Questions": "How to access static nested classes? ",
        "A": "OuterClass.StaticNestedClass",
        "B": "OuterClass->StaticNestedClass",
        "C": " OuterClass(StaticNestedClass)",
        "D": "OuterClass[StaticNestedClass].",
        "Answer": "A",
        "Explanation": "Like any other member of the class, the static nested class uses the dot operator to be accessed. The reason behind is, the static classes can’t work with instances, hence we use enclosing class name to access static nested class.",
        "Difficulty": "3",
        "StID": "4"
    },
    {
        "Questions": "How to create object of the inner class?       ",
        "A": "OuterClass.InnerClass innerObject = outerObject.new InnerClass();",
        "B": "OuterClass.InnerClass innerObject = new InnerClass();",
        "C": "InnerClass innerObject = outerObject.new InnerClass();",
        "D": "OuterClass.InnerClass = outerObject.new InnerClass();",
        "Answer": "A",
        "Explanation": "An instance of inner class can exist only within instance of outer class. To instantiate the inner class, one must instantiate the outer class first. This can be done by the correct syntax above.",
        "Difficulty": "2",
        "StID": "4"
    },
    {
        "Questions": "What will be the output of the following code?  public class Test\r\n{\r\n public int a=0;\r\n class innerClass\r\n {\r\n  public int a=1;\r\n  void innermethod(int x)\r\n  {\r\n   System.out.println(“value of x = ” + x);\r\n   System.out.println(“value of this.x = ” + this.x);\r\n   System.out.println(“value of Test.this.x = ” + Test.T=this.x);\r\n  }\r\n }\r\n} \r\npublic static void main( String args[] )\r\n{\r\n Test t=new Test();\r\n Test.innerClass im=t.new innerClass();\r\n im.innermethod(55);\r\n}",
        "A": "value of x = 55   value of this.x = 0 value of Test.this.x = 1",
        "B": "value of x = 1  value of this.x = 0  value of Test.this.x = 55",
        "C": "value of x = 55 value of this.x = 1\r\nvalue of Test.this.x = 0",
        "D": "value of x = 0  value of this.x = 55 value of Test.this.x = 1",
        "Answer": "C",
        "Explanation": "The variable x denotes the parameter of the function. And this.x is the variable of the inner class. Test.this.x is the variable of the outer class. Hence we get this output.",
        "Difficulty": "3",
        "StID": "4"
    },
    {
        "Questions": "Instance of inner class can exist only _______________ enclosing class.  ",
        "A": "Within",
        "B": "Outside",
        "C": "Private to",
        "D": "Public to",
        "Answer": "A",
        "Explanation": "The class defined inside another class is local to the enclosing class. This means that the instance of inner class will not be valid outside the enclosing class. There is no restriction for instance to be private or public always.",
        "Difficulty": "2",
        "StID": "4"
    },
    {
        "Questions": "If a declaration of a member in inner class has the same name as that in the outer class, then ________________ enclosing scope.   ",
        "A": "Outer declaration shadows inner declaration in",
        "B": "Inner declaration shadows outer declaration in",
        "C": "Declaration gives compile time error",
        "D": "Declaration gives runtime error",
        "Answer": "B",
        "Explanation": " The inner class will have more preference for its local members than those of the enclosing members. Hence it will shadow the enclosing class members. This process is known as shadowing.",
        "Difficulty": "2",
        "StID": "4"
    },
    {
        "Questions": "A static nested class is _____________ class in behavior that is nested in another _________ class. ",
        "A": "Top level, top level",
        "B": "Top level, low level",
        "C": "Low level, top level",
        "D": "Low level, low level",
        "Answer": "A",
        "Explanation": "Top level class encloses the other classes or have same preference as that of other top level classes. Having a class inside the top level class is indirectly having a top level class which higher degree of encapsulation.",
        "Difficulty": "2",
        "StID": "4"
    },
    {
        "Questions": "In how many ways can an object be passed to a function?   ",
        "A": "1",
        "B": "2",
        "C": "3",
        "D": "4",
        "Answer": "C",
        "Explanation": "The objects can be passed in three ways. Pass by value, pass by reference and pass by address. These are the general ways to pass the objects to a function.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "If an object is passed by value, ____________________  ",
        "A": "A new copy of object is created implicitly",
        "B": "The object itself is used",
        "C": "Address of the object is passed",
        "D": "A new object is created with new random values",
        "Answer": "A",
        "Explanation": "When an object is passed by value, a new object is created implicitly. This new object uses the implicit values assignment, same as that of the object being passed.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "Pass by address passes the address of object _________ and pass by reference passes the address of the object _________   ",
        "A": "Explicitly, explicitly",
        "B": "Implicitly, implicitly",
        "C": "Explicitly, Implicitly",
        "D": "Implicitly, explicitly",
        "Answer": "C",
        "Explanation": "Pass by address uses the explicit address passing to the function whereas pass by reference implicitly passes the address of the object.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "If an object is passed by reference, the changes made in the function ___________ ",
        "A": "Are reflected to the main object of caller function too",
        "B": "Are reflected only in local scope of the called function",
        "C": " Are reflected to the copy of the object that is made during pass",
        "D": "Are reflected to caller function object and called function object also",
        "Answer": "A",
        "Explanation": "When an object is passed by reference, its address is passed implicitly. This will make changes to the main function whenever any modification is done.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "Constructor function is not called when an object is passed to a function, will its destructor be called when its copy is destroyed?  ",
        "A": "Yes, depending on code",
        "B": "Yes, must be called",
        "C": "No, since no constructor was called",
        "D": "No, since same object gets used",
        "Answer": "B",
        "Explanation": " Even though the constructor is not called when the object is passed to a function, the copy of the object is still created, where the values of the members are same. When the object have to be destroyed, the destructor is called to free the memory and resources that the object might have reserved.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "When an object is returned by a function, a _______________ is automatically created to hold the return value. ",
        "A": "Temporary object",
        "B": "Virtual object",
        "C": "New object",
        "D": "Data member",
        "Answer": "A",
        "Explanation": " The temporary object is created. It holds the return value. The values gets assigned as required, and the temporary object gets destroyed.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": " Is the destruction of temporary object safe (while returning object)?  ",
        "A": "Yes, the resources get free to use",
        "B": "Yes, other objects can use the memory space",
        "C": "No, unexpected side effects may occur",
        "D": "No, always gives rise to exceptions",
        "Answer": "C",
        "Explanation": "The destruction of temporary variable may give rise to unexpected logical errors. Consider the destructor which may free the dynamically allocated memory. But this may abort the program if another is still trying to copy the values from that dynamic memory.",
        "Difficulty": "3",
        "StID": "5"
    },
    {
        "Questions": "How to overcome the problem arising due to destruction of temporary object? ",
        "A": "Overloading insertion operator",
        "B": "Overriding functions can be used",
        "C": "Overloading parenthesis or returning object",
        "Answer": "D",
        "Explanation": "The problem can be solved by overloading the assignment operator to get the values that might be getting returned while the destructor free the dynamic memory. Defining copy constructor can help us to do this in even simpler way.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "How many objects can be returned at once?    ",
        "A": " Only 1",
        "B": "Only 2",
        "C": "Only 16",
        "D": "As many as required",
        "Answer": "A",
        "Explanation": "Like any other value, only one object can be returned at ones. The only possible way to return more than one object is to return address of an object array. But that again comes under returning object pointer.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "What will be the output of the following code?         Class A\r\n{ \r\n int i; \r\n public : A(int n)\r\n { \r\n  i=n; cout&lt;&lt;”inside constructor ”;\r\n } \r\n ~A(){\r\n  cout&lt;&lt;”destroying  ”&lt;&lt;i;\r\n }\r\n void seti(int n)\r\n {\r\n  i=n;\r\n }\r\n int geti()\r\n {\r\n  return I;\r\n }\r\n};    void t(A ob)\r\n{ \r\n cout&lt;&lt;”something ”;\r\n}\r\nint main()\r\n{\r\n A a(1);\r\n t(a);\r\n cout&lt;&lt;”this is i in main ”;\r\n cout&lt;&lt;a.geti();\r\n}",
        "A": "inside constructor something destroying 2this is i in main destroying 1",
        "B": "inside constructor something this is i in main destroying 1",
        "C": "inside constructor something destroying 2this is i in main",
        "D": "something destroying 2this is i in main destroying 1",
        "Answer": "A",
        "Explanation": "Although the object constructor is called only ones, the destructor will be called twice, because of destroying the copy of the object that is temporarily created. This is the concept of how the object should be passed and manipulated. advertisement",
        "Difficulty": "3",
        "StID": "5"
    },
    {
        "Questions": "It is necessary to return the object if it was passed by reference to a function.",
        "A": " Yes, since the object must be same in caller function",
        "B": "Yes, since the caller function needs to reflect the changes",
        "C": "No, the changes are made automatically",
        "D": "No, the changes are made explicitly",
        "Answer": "C",
        "Explanation": "Having the address being passed to the function, the changes are automatically made to the main function. In all the cases if the address is being used, the same memory location will be updated with new values.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "How many objects can be passed to a function simultaneously?",
        "A": "Only 1",
        "B": "Only an array",
        "C": "Only 1 or an array",
        "D": "As many as required",
        "Answer": "D",
        "Explanation": "There is no limit to how many objects can be passed. This works in same way as that any other variable gets passed. Array and object can be passed at same time also.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "If an object is passed by address, will be constructor be called?  ",
        "A": "Yes, to allocate the memory",
        "B": " Yes, to initialize the members",
        "C": "No, values are copied",
        "D": "No, temporary object is created",
        "Answer": "C",
        "Explanation": " A copy of all the values is created. If the constructor is called, there will be a compile time error or memory shortage. This happens because each time a constructor is called, it try to call itself again and that goes infinite times.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "Is it possible that an object of is passed to a function, and the function also have an object of same name?     ",
        "A": "No, Duplicate declaration is not allowed",
        "B": "No, 2 objects will be created",
        "C": "Yes, Scopes are different",
        "D": "Yes, life span is different",
        "Answer": "A",
        "Explanation": "There can’t be more than one variable or object with the same name in same scope. The scope is same, since the object is passed, it becomes local to function and hence function can’t have one more object of same name.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "What is reference to an object?    ",
        "A": " It is address of an object",
        "B": "t is address of where the variables and methods of object are stored",
        "C": "It is pointer having address of an object",
        "D": "t is address of only variables and not the methods of an object",
        "Answer": "B",
        "Explanation": "Reference indicates the address where the object’s variables and methods are stored. It is not actual address of the object. This is done to directly use the variables and methods whenever required.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "Whenever an object is assigned to a variable or passed to a method, ________________ ",
        "A": "Actually the objects aren’t used",
        "B": "Actually only the objects are used",
        "C": "Actually a pointer to an object is used",
        "D": "Actually copy of object is used",
        "Answer": "A",
        "Explanation": "Whenever an object is assigned to a variable or passed to a method, we aren’t actually using objects there. Actually the reference to the objects is used. The reference makes a lot of difference as the main object may or may not get affected depending on the code.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "Does use of object reference in assignment or passing means copy of the object is being used?",
        "A": "No, because the copy would create a new temporary variable",
        "B": "No, because the copy would not help to make changes to main object",
        "C": "Yes, because the reference directly means using address",
        "D": "Yes, because the reference directly means the constructors are involved",
        "Answer": "C",
        "Explanation": "We can’t say that the reference involves constructors in passing the objects to some method. The reference is used to denote the addresses and hence to point to the main object itself. There is no copy involved.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "What will be the output of the following code?      import java.awt.Point;\r\nclass Testing\r\n{\r\n public static void main(String[] args)\r\n {\r\n  Point p1,p2;\r\n  p1=new Point(100,100);\r\n  p2=p1;\r\n  p1.x=200;\r\n  p1.y=200;\r\n  System.out.println(“Point 1: ” + p1.x + ”, “ + p1.y);\r\n  System.out.println(“Point 2: ” + p2.x + ”, “ + p2.y);\r\n }\r\n}",
        "A": "Point 1: 100, 100 Point 2: 200,200",
        "B": "Point 1: 200, 200 Point 2: 100,100",
        "C": "Point 1: 100, 100 Point 2: 100,100",
        "D": "Point 1: 200, 200 Point 2: 200,200",
        "Answer": "D",
        "Explanation": "The expected output would be like p2 with values 100, 100. But this is not the case. The tricky part is assignment used ( p2=p1; ). Here a reference is created from object p1 to p2, and not any new object that would copy p1’s values. Hence when we change the values of p1 object members. There changes are reflected to the object p2 also.",
        "Difficulty": "3",
        "StID": "5"
    },
    {
        "Questions": "Is there any explicit use of pointers in java that would be applicable to objects?",
        "A": "Yes, we use reference for this purpose",
        "B": "Yes, we use java arrays for this purpose",
        "C": "No, implicit pointing is possible",
        "D": "No, direct class names should be used",
        "Answer": "C",
        "Explanation": " The question clearly asks if there is any explicit use of pointers related to objects. Pointers are not applicable in java first of all. Secondly, the pointing in java is achieved implicitly using the references and object arrays. Now first two options are wrong because they use implicit pointing, and not any explicit pointing.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "Can a super class object give reference to a subclass method? ",
        "A": "No, it is not possible",
        "B": "Maybe, it is possible",
        "C": "No, it’s not possible",
        "D": "No, It’s not possible in few cases only",
        "Answer": "C",
        "Explanation": "The object of a super class can never refer to methods of a subclass. Whereas vice versa is possible. If there is an overridden function in subclass, then the object of super class will execute the method of itself and not from the subclass.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "What will be the output of the following code?   import java.awt.Point;\r\nclass Testing\r\n{\r\n public static void main(String[] args)\r\n {\r\n  Point t1,t2,t3;\r\n  t1=new Point(100,100);\r\n  t2=t1;\r\n  t3=t1;\r\n  t1.x=200;\r\n  t1.y=200;\r\n  t2.x=300;\r\n  t3.y=500;\r\n  System.out.println(“Point 1: ” + p1.x + ”, “ + p1.y);\r\n }\r\n}",
        "A": "Point 1: 200, 200",
        "B": "Point 1: 100,100",
        "C": "Point 1: 300, 300",
        "D": "Point 1: 300, 500",
        "Answer": "D",
        "Explanation": "When references are used, all the variables point to the same object. Whenever any of the variable changes any values, it will be reflected to all the variables pointing to the same object.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "If a reference variable is declared final then, _________________   ",
        "A": "It can never be reassigned to refer to a different object.",
        "B": "It can be assigned to refer to any object anytime",
        "C": "It can never be assigned with any object",
        "D": "It can be assigned with 2 or more objects simultaneously",
        "Answer": "A",
        "Explanation": "Since the variable is declared final. It will have a constant value throughout the program. It can refer to only one object at a time. And if it was made to refer to none of the object, it would have got no use.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "Which of the members are referred by this pointer usually (Java)? ",
        "A": "Members of class where this is used",
        "B": "Member of the parent class where this is used",
        "C": "Members that are passed as argument to the object",
        "D": "Pointers are not applicable in java",
        "Answer": "A",
        "Explanation": " We use this pointer to differentiate the members of the class where this is used to the other inherited or passed variables. The local variables are denoted with this. Or specifically the members of class only.",
        "Difficulty": "3",
        "StID": "5"
    },
    {
        "Questions": "How to refer to method of nested class?   ",
        "A": "enclosingClassObject.innerClassObject.method();",
        "B": "innerClassObject.method();",
        "C": "method();",
        "D": "depends on where the method is being called",
        "Answer": "D",
        "Explanation": "This depends on where the method is being called. If the method is called inside the enclosing class itself. Then we can’t use object of enclosing class. If the method is being called within the inner class itself, then its object will also be of no use.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "How many objects can be referenced from same variables?",
        "A": "One at a time",
        "B": "Many at a time",
        "C": "Many using array name",
        "D": "7 at max at same time",
        "Answer": "A",
        "Explanation": "There should not be any confusion in how many references can be made from a single variable. A single variable can only point to one object at a time. Even if it’s an array, the name of array is used and is considered one object name only (representing first array element).",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "Which among the following is true?      ",
        "A": "Object referencing refers to methods address",
        "B": "Object referencing refers to variable of object",
        "C": "Object referencing points to same address, if assigned by variables",
        "D": "Object referencing is used to point methods",
        "Answer": "C",
        "Explanation": " The object referencing will point to the same address if variables are assigned. All the variables might have a different name but they will point to the same memory location. This is most basic concept of references.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "Invoking a method on a particular object is ____________ sending a message to that object.",
        "A": "Different from",
        "B": "Same as",
        "C": "Somewhat similar",
        "D": "Part of",
        "Answer": "B",
        "Explanation": " The methods invoked on a particular object is same as sending a message with same values to that object. Message would contain values in a particular format which can be used by the object. And calling a method would be just another way to do the same task.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "Can reference to an object be returned from a method?           ",
        "A": "Yes, always possible",
        "B": "Yes, but not always",
        "C": "No, never possible",
        "D": "No, Not possible because referred element would be destroyed",
        "Answer": "B",
        "Explanation": "This is possible but not always, since the reference being returned may get destroyed with the return of method. This is an undesirable condition, hence it is not always possible to return references. But it is always possible if the referred element is not local to the method.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "What does memory allocation for objects mean?   ",
        "A": "Actual creation and memory allocation for object members",
        "B": "Creation of member functions",
        "C": "Creation of data members for a class",
        "D": "Actual creation and data declaration for object members",
        "Answer": "A",
        "Explanation": "The memory allocated for the object members indicates actual creation of the object members. This is known as memory allocation for object.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "Where is the memory allocated for the objects?     ",
        "A": "HDD",
        "B": "Cache",
        "C": "RAM",
        "D": "ROM",
        "Answer": "C",
        "Explanation": "The memory for the objects or any other data is allocated in RAM initially. This is while we run a program all the memory allocation takes place in some RAM segments. Arrays in heap and local members in stack etc.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "When is the memory allocated for an object?      ",
        "A": "At declaration of object",
        "B": "At compile time",
        "C": "When object constructor is called",
        "D": "When object is initialized to another object",
        "Answer": "D",
        "Explanation": " The object memory allocation takes place when the object constructor is called. Declaration of an object doesn’t mean that memory is allocated for its members. If object is initialized with another object, it may just get a reference to the previously created object.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "Using new is type safe as _______________________    ",
        "A": "It require to be specified with type of data",
        "B": "It doesn’t require to be specified with type of data",
        "C": "It requires the name of data",
        "D": "It allocated memory for the data",
        "Answer": "D",
        "Explanation": "The new is type safe because we don’t have to specify the type of data that have to be allocated with memory. We can directly use it with data name. Name of the data doesn’t matter though for type of memory allocation though.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "Which of the following function can be used for dynamic memory allocation of objects?",
        "A": "malloc()",
        "B": "calloc()",
        "C": "create()",
        "D": "malloc() and calloc()",
        "Answer": "D",
        "Explanation": "The malloc() function can be used to allocate dynamic memory for objects. Function calloc() can also be use. These functions differ in the way they allocate memory for objects.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "How much memory will be allocated for an object of class given below? class Test\r\n{\r\n int mark1;\r\n int mark2;\r\n float avg;\r\n char name[10];\r\n};",
        "A": " 22 Bytes",
        "B": " 24 Bytes",
        "C": "20 Bytes",
        "D": "18 Bytes",
        "Answer": "A",
        "Explanation": "The size of an object of the class given in question will be of size 22 bytes. This is because the size of an object is always equal to the sum of sizes of the data members of the class, except static members.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "When is the memory allocated for an object gets free? ",
        "A": "At termination of program",
        "B": "When object goes out of scope",
        "C": " When main function ends",
        "D": "When system restarts",
        "Answer": "B",
        "Explanation": "Whenever an object goes out of scope, the deletion of allocation memory takes place. Actually the data is not deleted, instead the memory space is flagged to be free for further use. Hence whenever an object goes out of scope the object members become useless and hence memory is set free.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "Which among the following keyword can be used to free the allocated memory for an object?",
        "A": "delete",
        "B": "free",
        "C": "either delete or free",
        "D": "only delete",
        "Answer": "C",
        "Explanation": "The memory allocated for an object is usually automatically made free. But if explicitly memory has to be made free then we can use either free or delete keywords depending on programming languages.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "Which function is called whenever an object goes out of scope? ",
        "A": "Destructor function",
        "B": "Constructor function",
        "C": "Delete function",
        "D": "Free function",
        "Answer": "A",
        "Explanation": "The destructor function of the class is called whenever an object goes out of scope. This is because the destructor set all the resources, acquired by the object, free. This is an implicit work of compiler.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "Which operator can be used to check the size of an object?  ",
        "A": "sizeof(objectName)",
        "B": "size(objectName)",
        "C": "sizeofobject(objectName)",
        "D": "sizedobject(objectName)",
        "Answer": "A",
        "Explanation": "The sizeof operator is used to get the size of an already created object. This operator must constail keyword sizeof(objectName). The output will give the number of bytes acquired by a single object of some class.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "The memory allocated for an object ____________________ ",
        "A": "Can be only dynamic",
        "B": "Can be only static",
        "C": " Can be static or dynamic",
        "D": "Can’t be done using dynamic functions",
        "Answer": "D",
        "Explanation": "The memory allocation for an object can be static or dynamic. The static memory allocation is when an object is declared directly without using any function usually. And dynamic allocation is when we use some dynamic allocation function to allocate memory for data member of an object.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "If an object is declared in a user defined function __________________",
        "A": "Its memory is allocated in stack",
        "B": "Its memory is allocated in heap",
        "C": "Its memory is allocated in HDD",
        "D": "Its memory is allocated in cache",
        "Answer": "A",
        "Explanation": "The memory for any data or object that are used in a user defined function are always allocated in the stack. This is to ensure that the object is destroyed as soon as the function is returned. Also this ensures that the correct memory allocation and destruction is performed.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "In java, ____________________ takes care of managing memory for objects dynamically",
        "A": "Free collector",
        "B": "Dust collector",
        "C": " Memory manager",
        "D": "Garbage collector",
        "Answer": "D",
        "Explanation": "The garbage collector in java takes care of the memory allocations and their deletions dynamically. When an object is no more required then the garbage collector deletes the object and free up all the resources that were held by that object.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "Which operator can be used to free the memory allocated for an object in C++?    ",
        "A": "Free()",
        "B": "delete",
        "C": "Unallocate",
        "D": "Collect",
        "Answer": "B",
        "Explanation": "The delete operator in C++ can be used to free the memory and resources held by an object. The function can be called explicitly whenever required. In C++ memory management must be done by the programmer. There is no automatic memory management in C++.\r\n",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "What is array of objects?    ",
        "A": "An array of instances of class represented by single name",
        "B": "An array of instances of class represented by more than one name",
        "C": "An array of instances which have more than 2 instances",
        "D": "An array of instances which have different types",
        "Answer": "A",
        "Explanation": "The array of objects an array of instances of a class. The array is represented by a single name. The array name is itself a pointer. Array name represents the first object.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "Which among the following is a mandatory condition for array of objects?          ",
        "A": "All the objects should be of different class",
        "B": "All the objects should be of same program classes",
        "C": " All the objects should be of same class",
        "D": "All the objects should have different data",
        "Answer": "C",
        "Explanation": "The objects of an array must be of same class. This is mandatory because array is set of same type of elements. The objects of same class are considered to be of same type.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "What is the type of the elements of array of objects?        ",
        "A": "Class",
        "B": "Void",
        "C": "String",
        "D": "Null",
        "Answer": "A",
        "Explanation": "The class itself is the type of elements of array of objects. All the objects possess the same properties. Like any other primitive data type, the objects are of their respective class type.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "If array of objects is declared as given below, which is the limitation on objects?  Class_name arrayName[size];",
        "A": "The objects will have same values",
        "B": "The objects will not be initialized individually",
        "C": " The objects can never be initialized",
        "D": "The objects will have same data",
        "Answer": "B",
        "Explanation": "If the syntax given, is used to declare the array of objects, then the objects can’t be initialized individually. All the objects will have to be initialized after this declaration.",
        "Difficulty": "3",
        "StID": "5"
    },
    {
        "Questions": "Which is the condition that must be followed if the array of objects is declared without initialization, only with size of array?   ",
        "A": "The class should have separate constructor for each object",
        "B": "The class must have no constructors",
        "C": "The class should not have any member function",
        "D": "The class must have a default or zero argument constructor",
        "Answer": "D",
        "Explanation": "The class must have a default/zero argument constructor. Since the declaration is done by only specifying the size of array, the class must have default a construct to be called by default to reserve memory for each object. Also, we can’t specify the arguments in this type of declaration hence the class should provide a default initialization.",
        "Difficulty": "3",
        "StID": "5"
    },
    {
        "Questions": "When are the array of objects without any initialization useful?            ",
        "A": "When object data is not required just after the declaration",
        "B": "When initialization of object data is to be made by the compiler",
        "C": "When object data doesn’t matter in the program",
        "D": "When the object should contain garbage data",
        "Answer": "A",
        "Explanation": " Sometimes the object data is not mandatory to be used just after the declaration or may be the program requires the data to be updated according to what user inputs. Hence only declaration us also useful.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "If constructor arguments are passed to objects of array then ____________ if the constructors are overloaded.    ",
        "A": "It is mandatory to pass same number of arguments to all the objects",
        "B": "It is mandatory to pass same type of arguments to all the objects",
        "C": "It is not mandatory to call same constructor for all the objects",
        "D": "It is mandatory to call same constructor for all the constructors",
        "Answer": "C",
        "Explanation": " It is not mandatory to call the same constructor for all the objects in an array if initialized with the declaration. The objects can be passed with different set of arguments in the same syntax, separated by commas.",
        "Difficulty": "3",
        "StID": "5"
    },
    {
        "Questions": "How the objects of array can be denoted?   ",
        "A": "Indices",
        "B": "Name",
        "C": "Random numbers",
        "D": "Alphabets",
        "Answer": "A",
        "Explanation": "Different objects in an array can be denoted with the indices of array. The first object is denoted by 0. And the further indices denote the next objects in sequence of array.",
        "Difficulty": "3",
        "StID": "5"
    },
    {
        "Questions": "The objects in an object array _______________________   ",
        "A": "Can be created without use of constructor",
        "B": " Can be created without calling default constructor",
        "C": " Can’t be created with use of constructor",
        "D": "Can’t be created without calling default constructor",
        "Answer": "D",
        "Explanation": "The objects need some constructor to get the memory spaced reserved for those. If the default constructor is not used then we can use some arguments constructor which will reserve the memory for the objects. The objects can be passed with constructor arguments during declaration.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "The Object array is created in _____________________   ",
        "A": "Heap memory",
        "B": "Stack memory",
        "C": "HDD",
        "D": "ROM",
        "Answer": "A",
        "Explanation": " If the object arrays are declared dynamically, then the memory will be reserved on heap. The memory for objects will be on stack only if some constructor or some call and return tasks are happening. The program doesn’t run on HDD and ROM is not used for execution of programs.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "_______________ syntax should be used.         ",
        "A": "Array_Name[4].data_variable_name;",
        "B": " Data_Type Array_Name[4].data_variable_name;",
        "C": "Array_Name[4].data_variable_name.value;",
        "D": "Array_Name[4].data_variable_name(value);",
        "Answer": "A",
        "Explanation": "The array name with the index of fifth element is called, i.e. index 4. Then the dot operator is used to access the data member of that object. This Allows us to access the data members of all the objects in an object array.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "Can we have two dimensional object array?     ",
        "A": "Yes, always",
        "B": "Yes, only if primitive type array",
        "C": "No, since two indices are impossible",
        "D": "No, never",
        "Answer": "A",
        "Explanation": "A two dimensional array can always be created. There is no rule that only primitive type objects can have more than one dimension. The object array can also be made 2 dimensional. advertisement",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "From which index does the array of objects start?     ",
        "A": "0",
        "B": "1",
        "C": "2",
        "D": "3",
        "Answer": "A",
        "Explanation": "The index must start from 0. The index ends at size – 1 index. This is because the index is always till n-1 where n is the total number of beads.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "Is an array of characters always a string? ",
        "A": "Yes, always",
        "B": "Yes, if each character is terminated by null",
        "C": "No, since each character is terminated by null",
        "D": "No, never",
        "Answer": "D",
        "Explanation": "The character arrays are not same as string. The string once created then remains the same. The character array values may change.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "Which among the following is main use of object?   ",
        "A": "To create instance of a function",
        "B": "To create instance of a program",
        "C": "To create instance of class",
        "D": "To create instance of structures",
        "Answer": "C",
        "Explanation": "The objects are used to create instance of a class. Objects can represent a class in an independent form. The basic blueprint, that contains the information of the type of data that can be stored in an object, is given by the class.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "Which among the following is not a property of an object?",
        "A": "Identity",
        "B": "Properties",
        "C": "Attributes",
        "D": "Names",
        "Answer": "D",
        "Explanation": "The names are not property of an object. The identity can be in any form like address or name of object but name can’t be termed as only identity of an object. The objects contain attributes that define what type of data an object can store.",
        "Difficulty": "3",
        "StID": "5"
    },
    {
        "Questions": "What is function object?   ",
        "A": "An object with a single function",
        "B": "An object with only functions",
        "C": "An object with more than one function",
        "D": "An object with no functions",
        "Answer": "A",
        "Explanation": "A function object is the object with single function. In C++ a function object can be like operator() function. This acts more like a function rather than an object.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "Immutable object are used ______________________  ",
        "A": "To set up as a fixed state",
        "B": "To set up variable object",
        "C": "To set up an object of abstract class",
        "D": "To set up an object of derived class",
        "Answer": "A",
        "Explanation": "An immutable object can be created for an object which have to be fixed with values. The object data will not be changed throughout the program. This can be useful to eliminate the unintentional changes in the data of object.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "Which object can be used to contain other objects?   ",
        "A": "First class object",
        "B": "Derived class object",
        "C": "Container object",
        "D": "Enclosure object",
        "Answer": "C",
        "Explanation": "A container object can be used to contain other objects. Container object is an ADT. Its object are collection of other objects. Some specific rules apply to these type of objects.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "A factory object is used ______________________               ",
        "A": "To create new classes",
        "B": "To create new function",
        "C": "To create new data members",
        "D": "To create new objects",
        "Answer": "D",
        "Explanation": "The factory object is an object that can be used to create other objects. If it is seen formally, it behaves like a method that will return object on its use. The object returned is assumed to be a new object.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "What are singleton objects? ",
        "A": "The only two objects of a class throughout the program",
        "B": "The only object of a class throughout the program",
        "C": "The objects that are alive throughout the program",
        "D": "The objects that are created and then deleted without use",
        "Answer": "B",
        "Explanation": "If a class has only one object created and that is the only object of the class. Then the object is known as singleton object. But only if that object is the only object of the class and no other object is created for that class.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "Object cout and cin _________________            ",
        "A": "Can be used directly with << and >> symbols respectively",
        "B": "Can be used directly with >> and << symbols respectively",
        "C": "Must be used as a function which accepts 2 arguments",
        "D": "Must be used as a function which accepts 3 arguments",
        "Answer": "A",
        "Explanation": "The cin and cout objects can be used directly with the >> and << operators respectively. The objects are of iostream class. Class iostream is an inbuilt class.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "Objects type ____________________        ",
        "A": "Can be changed in runtime",
        "B": "Can’t be changed in runtime",
        "C": "Can be changed in compile time",
        "D": "May or may not get changed",
        "Answer": "B",
        "Explanation": "The object types are always fixed. Once the object is created of a specific type then it can’t be changed. Neither at runtime nor at compile time.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "An object can be used to represent _________________  ",
        "A": "A real world entity",
        "B": "A real function",
        "C": "Some real data only",
        "D": "Some function only",
        "Answer": "A",
        "Explanation": "The objects are actually meant to represent an entity. The classes are real world object’s blueprint. The classes then are used to create an entity representation.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "Objects can be used _____________________  ",
        "A": "To access any member of a class",
        "B": "To access only public members of a class",
        "C": "To access only protected members of a class",
        "D": "To access only private members of a class",
        "Answer": "B",
        "Explanation": "The objects are created for a specific class. Then the objects can be used to access the public members of a class. The members can be the data members or the member functions of the class.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "Which among the following is not a use of object?          ",
        "A": "Defining a member function",
        "B": "Accessing data members",
        "C": "Creating instance of a class",
        "D": "Using class members",
        "Answer": "A",
        "Explanation": "The objects can’t be used to define any member function. Member functions must be defined by the class only. Objects can only access the members and use them. advertisement",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "Which object can be used to access the standard input?         ",
        "A": "System.inner ",
        "B": "cin",
        "C": "System.stdin",
        "D": "console.input",
        "Answer": "B",
        "Explanation": "Object cin can be used to take input from the standard input. It is used in C++. In java we can use System.in for the standard input stream. The syntax changes from language to language.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "A single object can be used __________________       ",
        "A": "As only two class types at a time",
        "B": "As only three class types at a time",
        "C": "As only one class type at a time",
        "D": "As of as many class types as required",
        "Answer": "C",
        "Explanation": "The object can be of only one type. The type of an object can’t be changed. Object type is mandatory to be of one class type to ensure the type and number of data members it have.",
        "Difficulty": "1",
        "StID": "5"
    },
    {
        "Questions": "If same object name is given to different objects of different class then _____________",
        "A": "Its compile time error",
        "B": "Its runtime error",
        "C": "It’s not an error",
        "D": "Program suns smooth",
        "Answer": "A",
        "Explanation": " It is a compile time error as the compiler doesn’t allow same name objects to be declared more than once. Compiler produces multiple declaration error. Every object must have a different name.",
        "Difficulty": "2",
        "StID": "5"
    },
    {
        "Questions": "Which among the following best describes the Inheritance?  ",
        "A": "Copying the code already written",
        "B": "Using the code already written once",
        "C": "Using already defined functions in programming language",
        "D": "Using the data and functions into derived segment",
        "Answer": "D",
        "Explanation": "It can only be indicated by using the data and functions that we use in derived class, being provided by parent class. Copying code is nowhere similar to this concept, also using the code already written is same as copying. Using already defined functions is not inheritance as we are not adding any of our own features.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "How many basic types of inheritance are provided as OOP feature?     ",
        "A": "4",
        "B": "3",
        "C": "2",
        "D": "1",
        "Answer": "A",
        "Explanation": "There are basically 4 types of inheritance provided in OOP, namely, single level,multilevel, multiple and hierarchical inheritance. We can add one more type as Hybrid inheritance but that is actually the combination any types of inheritance from the 4 basic ones.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "Which among the following best defines single level inheritance?    ",
        "A": "A class inheriting a derived class",
        "B": " A class inheriting a base class",
        "C": "A class inheriting a nested class",
        "D": "A class which gets inherited by 2 classes",
        "Answer": "B",
        "Explanation": "A class inheriting a base class defines single level inheritance. Inheriting an already derived class makes it multilevel inheritance. And if base class is inherited by 2 other classes, it is multiple inheritance.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Which among the following is correct for multiple inheritance?   ",
        "A": "class student{public: int marks;}s; class stream{int total;}; class topper:public student, public stream{ };",
        "B": "class student{int marks;}; class stream{ }; class topper: public student{ };",
        "C": "class student{int marks;}; class stream:public student{ };",
        "D": "class student{ }; class stream{ }; class topper{ };",
        "Answer": "A",
        "Explanation": "Class topper is getting derived from 2 other classes and hence it is multiple inheritance. Topper inherits class stream and class student publicly and hence can use its features. If only few classes are defined, there we are not even using inheritance (as in option d).",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "Which programming language doesn’t support multiple inheritance? ",
        "A": "C++ and Java",
        "B": " C and C++",
        "C": "Java and SmallTalk",
        "D": "Java",
        "Answer": "D",
        "Explanation": "Java doesn’t support multiple inheritance. But that feature can be implemented by using the interfaces concept. Multiple inheritance is not supported because of diamond problem and similar issues.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "Which among the following is correct for hierarchical inheritance?   ",
        "A": " Two base classes can be used to be derived into one single class",
        "B": " Two or more classes can be derived into one class",
        "C": " One base class can be derived into other two derived classes or more",
        "D": "One base class can be derived into only 2 classes",
        "Answer": "D",
        "Explanation": "One base class can be derived into other two derived classes or more. If only one class gets derived by only 2 other classes, it is also hierarchical inheritance, but it is not a mandatory condition, because any number of derived classes can be there.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Which is the correct syntax of inheritance?     ",
        "A": "class derived_classname : base_classname{ /*define class body*/ };",
        "B": "class base_classname : derived_classname{ /*define class body*/ };",
        "C": "class derived_classname : access base_classname{ /*define class body*/ };",
        "D": "class base_classname :access derived_classname{ /*define class body*/ };",
        "Answer": "C",
        "Explanation": " Firstly, keyword class should come, followed by the derived class name. Colon is must followed by access in which base class has to be derived, followed by the base class name. And finally the body of class. Semicolon after the body is also must.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Which type of inheritance leads to diamond problem?       ",
        "A": "Single level",
        "B": "Multi-level",
        "C": " Multiple",
        "D": "Hierarchical",
        "Answer": "C",
        "Explanation": " When 2 or more classes inherit the same class using multiple inheritance and then one more class inherits those two base classes, we get a diamond like structure. Here, ambiguity arises when same function gets derived into 2 base classes and finally to 3rd level class, because same name functions are being inherited.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "Which access type data gets derived as private member in derived class:    ",
        "A": "Private",
        "B": "Public",
        "C": "Protected",
        "D": "Protected and Private",
        "Answer": "A",
        "Explanation": " It is a rule, that when a derived class inherits the base class in private access mode, all the members of base class gets derived as private members of the derived class.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "If a base class is inherited in protected access mode then which among the following is true? ",
        "A": "Public and Protected members of base class becomes protected members of derived class",
        "B": "Only protected members become protected members of derived class",
        "C": "Private, Protected and Public all members of base, become private of derived class",
        "D": "Only private members of base, become private of derived class",
        "Answer": "A",
        "Explanation": "As the programming language rules apply, all the public and protected members of base class becomes protected members of derived class in protected access mode. It can’t be changed because it would hinder the security of data and may add vulnerability in program.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "Members which are not intended to be inherited are declared as:                    ",
        "A": " Public members",
        "B": "Protected members",
        "C": "Private members",
        "D": "Private or Protected members",
        "Answer": "C",
        "Explanation": "Private access specifier is the most secure access mode. It doesn’t allow members to be inherited. Even Private inheritance can only inherit protected and public members.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "While inheriting a class, if no access mode is specified, then which among the following is true? (in C++)      ",
        "A": "t gets inherited publicly by default",
        "B": "It gets inherited protected by default",
        "C": "It gets inherited privately by default",
        "D": "It is not possible",
        "Answer": "C",
        "Explanation": " If the access mode is not specified during inheritance, the class is inherited privately by default. This is to ensure the security of data and to maintain OOP features. Hence it is not mandatory to specify the access mode if we want the class to be inherited privately.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "If a derived class object is created, which constructor is called first?      ",
        "A": "Base class constructor",
        "B": "Derived class constructor",
        "C": "Depends on how we call the object",
        "D": "Not possible",
        "Answer": "A",
        "Explanation": "First the base class constructor is invoked. When we create a derived class object, the system tries to invoke its constructor but the class is derived so first the base class must be initialized, hence in turn the base class constructor is invoked before derived class constructor.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "How can you make the private members inheritable?      ",
        "A": "By making their visibility mode as public only",
        "B": "By making their visibility mode as protected only",
        "C": "By making their visibility mode as private in derived class",
        "D": "It can be done both by making the visibility mode public or protected",
        "Answer": "D",
        "Explanation": "It is not mandatory that you have to make the visibility mode either public or protected. You can do either of those. That will give you permission to inherit the private members of base class.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "Multiple inheritance is ____________________       ",
        "A": " When a class is derived from another class",
        "B": "When a class is derived from two or more classes",
        "C": "When a class is derived from two or more classes",
        "D": "When a class is derived from exactly one class",
        "Answer": "B",
        "Explanation": "The multiple inheritance is used when a class is being derived using two base classes or more. This way a single class can have features of more than one classes inherited into a single unit. This lets us combine two class members into a single class.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "Which problem arises due to multiple inheritance, if hierarchical inheritance is used previously for its base classes?      ",
        "A": "Diamond",
        "B": "Circle",
        "C": "Triangle",
        "D": "Loop",
        "Answer": "A",
        "Explanation": "The diamond problem arises when multiple inheritance is used. This problem arises because the same name member functions get derived into a single class. Which in turn creates ambiguity in calling those methods.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "How many classes should a program contain to implement the multiple inheritance?     ",
        "A": "Only 1",
        "B": "At least 1",
        "C": "At least 3",
        "D": " Exactly 3",
        "Answer": "C",
        "Explanation": "For the implementation of multiple inheritance, there must be at least 3 classes in a program. At least 2 base classes and one class to inherit those two classes. If lesser, it becomes single level inheritance.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Which programming language restricts the use of multiple inheritance?    ",
        "A": "C++",
        "B": " PHP",
        "C": "SmallTalk",
        "D": "Java",
        "Answer": "D",
        "Explanation": "Java doesn’t allow use of multiple inheritance with classes. But this can be done by using the interfaces. This is more secure and unambiguous way to implement multiple inheritance.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "Is it possible to have all the abstract classes as base classes of a derived class from those?                  ",
        "A": "Yes, always",
        "B": "Yes, only if derived class implements all the methods",
        "C": "No, because abstract classes doesn’t have constructors",
        "D": "No, never",
        "Answer": "B",
        "Explanation": "The condition for abstract class applies same here too. All the undefined functions must be defined. Hence all the base classes can be abstract but derived class must implement all those undefined functions.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "If class A inherits class B and class C as “class A: public class B, public class C {// class body ;}; ”, which class constructor will be called first?       ",
        "A": " Class A",
        "B": "Class B",
        "C": "Class C",
        "D": "All together",
        "Answer": "B",
        "Explanation": "The constructors of parent class will be called first. In that, the constructor of the classes will be called in the same sequence as that mentioned in class definition inheritance. Since class B is mentioned first for inheritance, its constructor will be called first.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "Why does diamond problem arise due to multiple inheritance?              ",
        "A": "Methods with same name creates ambiguity and conflict",
        "B": "Methods inherited from the superclass may conflict",
        "C": "Derived class gets overloaded with more than two class methods",
        "D": "Derived class can’t distinguish the owner class of any derived method",
        "Answer": "A",
        "Explanation": "All the derived classes can distinguish the base class members, but if a method is being inherited to the base classes from another class which again gets inherited into same class (diamond shape), that may create conflict in using the function from two available.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "How many base classes can a derived class have which is implementing multiple inheritance? ",
        "A": " Only 2",
        "B": "At least 2",
        "C": " At most 2",
        "D": " As many as required",
        "Answer": "D",
        "Explanation": "The classes can derive from as many classes as required since the multiple inheritance feature is made to combine or group together the functions that are from different classes. This make the derived class stronger in terms of its flexibility.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "How to overcome diamond problem ?             ",
        "A": "Using alias name",
        "B": "Using seperate derived class",
        "C": "Using virtual keyword with same name function",
        "D": "Can’t be done",
        "Answer": "C",
        "Explanation": " To overcome the ambiguity and conflict we can use keyword virtual. This will help us to differentiate the functions with same name that came to last derived class in diamond problem.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "When multiple inheritance is used, which class object should be used in order to access all the available members of parent and derived class ?      ",
        "A": "Derived class object",
        "B": " Parent class objects",
        "C": "Use Abstract derived class",
        "D": "Derive a class from derived class",
        "Answer": "A",
        "Explanation": "The derived class object can access all of its own members. It can also access the available members of the parent classes, because the members are derived into the derived class.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "If all the members of all the base classes are private then,           ",
        "A": "There won’t be any use of multiple inheritance",
        "B": " It will make those members public",
        "C": "Derived class can still access them in multiple inheritance",
        "D": "Compile time error",
        "Answer": "A",
        "Explanation": "The derived class will not be able to access any members of the base classes. Since private member’s are not inheritable. It leads to no use of multiple inheritance.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "Is it compulsory to have constructor for all the classes involved in multiple inheritance? ",
        "A": "Yes, always",
        "B": "Yes, only if no abstract class is involved",
        "C": "No, only classes being used should have a constructor",
        "D": "No, they must not contain constructors",
        "Answer": "B",
        "Explanation": "The constructors must be defined in every class. If class is abstract, it won’t have any constructor but other classes must have constructor. Either implicit or explicit.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "If a class contains 2 nested class and is being inherited by another class, will there be any multiple inheritance?       ",
        "A": "No, only single level inheritance is used",
        "B": "No, only multilevel inheritance is used",
        "C": "Yes, because 3 classes are involved",
        "D": "Yes, because more than 1 classes are being derived",
        "Answer": "A",
        "Explanation": "When a class having nested classes is being derived into another class. It indirectly means a simple class is being inherited to another class. This is single level inheritance.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Which members can’t be accessed in derived class in multiple inheritance ?   ",
        "A": "Private members of base",
        "B": "Public members of base",
        "C": " Protected members of base",
        "D": "All the members of base",
        "Answer": "A",
        "Explanation": "The private member’s are available for only the class containing those members. Derived classes will have access to protected and public members only.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "Can the derived class be made abstract if multiple inheritance is used ?             ",
        "A": "No, because other classes must be abstract too",
        "B": "Yes, if all the functions are implemented",
        "C": "Yes, if all the methods are predefined",
        "D": " No, since constructors won’t be there",
        "Answer": "C",
        "Explanation": "he derived class must not be abstract. This is because the abstract classes doesn’t have constructor and hence we won’t be having capability to have instances. This will restrict use of multiple inheritance.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "How many types of inheritance are possible in C++?         ",
        "A": "2",
        "B": "3",
        "C": "4",
        "D": "5",
        "Answer": "D",
        "Explanation": "There are five types of inheritance that are possible in C++. Single level, Multilevel, multiple, hierarchical and hybrid. Here we count hybrid also because it sometimes can bring up a new form of inheritance, Like inheritance using multiple and hierarchical, which sometimes results in diamond problem.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Which among the following is true?              ",
        "A": "Java supports all types of inheritance",
        "B": "Java supports multiple inheritance",
        "C": "Java doesn’t support multiple inheritance",
        "D": "Java doesn’t support inheritance",
        "Answer": "C",
        "Explanation": "Java doesn’t support multiple inheritance. This is done to avoid the diamond problem that sometimes arises with inherited functions. Though, multiple inheritance can be implemented in java using interfaces.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "Which type of inheritance is illustrated by the following code?   class student{ public: int marks; };\r\nclass topper: public student { public: char grade; };\r\nclass average{ public: int makrs_needed; };\r\nclass section: public average{ public: char name[10];  };\r\nclass overall: public average{  public: int students;  };",
        "A": "Single level",
        "B": "Multilevel and single level",
        "C": "Hierarchical",
        "D": "Hierarchical and single level",
        "Answer": "C",
        "Explanation": "It is hierarchical inheritance and single level inheritance. Since class topper is inheriting class student, it is single level inheritance. And then average is inherited by section and overall, so it is hierarchical inheritance. But both of them are separate. Hence it is not hybrid inheritance.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "Which among the following best describes multiple inheritance?    ",
        "A": "Two classes being parent of any other classes",
        "B": " Three classes being parent of other classes",
        "C": " More than one class being parent of other child classes",
        "D": " More than one class being parent of single child",
        "Answer": "D",
        "Explanation": " If a class inherits more than one class, it is known as multiple inheritance. This should not be referred with only two or three classes being inherited. But there must be one class which inherits more than one class to be called as multiple inheritance.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "How many types of inheritance can be used at a time in single program?   ",
        "A": "Any two types",
        "B": "Any three types",
        "C": "Any 4 types",
        "D": "Any type, any number of times",
        "Answer": "D",
        "Explanation": "Any type of inheritance can be used in any program. There is no rule to use only few types of inheritance. Only thing that matters is how the classes are inherited and used.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "If 6 classes uses single level inheritance with pair classes (3 pairs), which inheritance will this be called?",
        "A": "Single",
        "B": "Multiple",
        "C": "Hierarchical",
        "D": "Multilevel",
        "Answer": "A",
        "Explanation": "In diamond problem, hierarchical inheritance is used first, where two different classes inherit the same class and then in turn a 4th class inherits the two classes which had inherited the first class. Using more than one type of inheritance here, it is known as hybrid inheritance. ",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "If 6 classes uses single level inheritance with pair classes (3 pairs), which inheritance will this be called?",
        "A": "Single",
        "B": "Multiple",
        "C": "Hierarchical",
        "D": "Multilevel",
        "Answer": "A",
        "Explanation": "Here all the pairs are using single inheritance. And no different pairs are inheriting same classes. Hence it can’t be called hybrid or multilevel inheritance. You can say the single inheritance is used 3 times in that program.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "Which among the following is correct for the following code?            class A\r\n{  \r\n public : class B \r\n { \r\n  public : B(int i): data(i)\r\n  { \r\n  }\r\n  int data;\r\n }\r\n};\r\n class C: public A\r\n{\r\n class D:public A::B{ };\r\n};",
        "A": "Multi-level inheritance is used, with nested classes",
        "B": "Multiple inheritance is used, with nested classes",
        "C": "Single level inheritance is used, with enclosing classes",
        "D": "Single level inheritance is used, with both enclosing and nested classes",
        "Answer": "D",
        "Explanation": "Class C is inheriting Class A. Class D is inheriting class B, both are nested. Hence it is single inheritance. For multiple inheritance, class C or D should have inherited both class A and class B.advertisement",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "Which among the following is false?   ",
        "A": "If one class inherits the inherited class in single level inheritance, it is multi-level inheritance",
        "B": "Hybrid inheritance always contains multiple inheritance",
        "C": "Hierarchical inheritance involves inheriting same class into more than one classes",
        "D": "Hybrid inheritance can involve any types of inheritance together",
        "Answer": "D",
        "Explanation": "t is not necessary to have multiple inheritance in hybrid type. It can have any type together. This doesn’t have to be of specific type always.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "If class A has two nested classes B and C. Class D has one nested class E, and have inherited class A. If E inherits B and C, then:",
        "A": "It shows multiple inheritance",
        "B": "It shows hierarchical inheritance",
        "C": " It shows multiple inheritance",
        "D": "Multiple inheritance among nested classes, and single level for enclosing classes",
        "Answer": "D",
        "Explanation": "This involves the same concept of inheritance, where the nested classes also follow the inheritance rules. The Enclosing classes are having single inheritance. Nested classes involves multiple.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Which type of inheritance cannot involve private inheritance?         ",
        "A": "Single level",
        "B": " Multiple",
        "C": "Hybrid",
        "D": "All types can have private inheritance",
        "Answer": "D",
        "Explanation": "This is a common type of inheritance where the protected and public members of parent class become private members in child class. There is no type which doesn’t support private inheritance.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "How many classes can be inherited by a single class in multiple inheritance (C++)?   ",
        "A": "Only 2",
        "B": " Only 27",
        "C": "Only 1024",
        "D": "Any number of classes can be inherited",
        "Answer": "D",
        "Explanation": "Any class can inherit any number of classes. There is no limit defined for the number of classes being inherited by a single class.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "How many classes can be inherited by a single class in java? ",
        "A": " Only 1",
        "B": "Only 27",
        "C": "Only 255",
        "D": "Only 1024",
        "Answer": "A",
        "Explanation": "Since java doesn’t support multiple inheritance, it is not possible for a class to inherit more than 1 class in java. This is the same case in C# also.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "If multi-level inheritance is used, First class B inherits class A, then C inherits B and so on. Till how many classes can this go on?    ",
        "A": "Only till class C",
        "B": "Only till class J",
        "C": " Only till class Z",
        "D": "There is no limit",
        "Answer": "D",
        "Explanation": "In this case there is no limit. All the classes going on like this will inherit the members of base class, and hence the upper level inheritance won’t affect the number of classes that can go on inheriting in this pattern.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Which among the following is best to define hierarchical inheritance?    ",
        "A": "More than one classes being derived from one class",
        "B": "More than 2 classes being derived from single base class",
        "C": "At most 2 classes being derived from single base class",
        "D": "At most 1 class derived from another class",
        "Answer": "A",
        "Explanation": "When two or more classes get derived from a single base class, it is known as hierarchical inheritance. This gives us freedom to use same code with different scopes and flexibility into different classes.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "Do members of base class gets divided among all of its child classes ?    ",
        "A": "Yes, equally",
        "B": "Yes, depending on type of inheritance",
        "C": "No, it’s doesn’t get divided",
        "D": "No, it may or may not get divided",
        "Answer": "C",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Each class can inherit the base class ________________             ",
        "A": "Independently using any inheritance",
        "B": "Independently with private inheritance only",
        "C": "With same type of inheritance",
        "D": "With each class using different inheritance only",
        "Answer": "A",
        "Explanation": "The classes can inherit the base class using any type of inheritance. There is no mandatory condition to use same private,public or protected inheritance only.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "How many classes must be there to implement hierarchical inheritance ?      ",
        "A": "Exactly 3",
        "B": "At least 3",
        "C": "At most 3",
        "D": "At least 1",
        "Answer": "B",
        "Explanation": "At least 3 classes must be there. Two derived classes and one base class. This lets us implement two classes that have common characteristics from base class.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "Base class _______________    ",
        "A": "Can be made abstract",
        "B": "Can’t be made abstract",
        "C": " Must be abstract",
        "D": "If made abstract, compile time error",
        "Answer": "A",
        "Explanation": "The base class may or may not be declared abstract. It depends on the need of program. If it is made abstract, it can contain undefined functions too. In turn, those functions will have to be implemented by each of the derived classes.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Which access specifiers should be used so that all the derived classes restrict further inheritance of base class members?           ",
        "A": "Private",
        "B": "Public",
        "C": "Protected",
        "D": " Any inheritance type can be used",
        "Answer": "A",
        "Explanation": " All the derived classes must use private inheritance. This will make the members of base class private in derived classes. Hence none of the members of base class will be available for further inheritance.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "Which class uses hierarchical inheritance in following code?    class A\r\n{\r\n int a;\r\n};\r\nclass B:class A\r\n{\r\n int b;\r\n};\r\nclass C:class A,class B\r\n{ int c;\r\n};\r\nclass D:class A\r\n{\r\n int d;\r\n};",
        "A": " Class A,B,C",
        "B": "Class B,C,D",
        "C": "Class A,C,D",
        "D": "Class D,A,B",
        "Answer": "D",
        "Explanation": "Class A is base class and B and D are derived classes. If class C is considered, it shows hybrid inheritance, involving single level and multiple inheritance.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "Which among the following is correct for following code ?       abstract class A {\r\n public Int a;\r\n public void disp();\r\n};\r\nclass B:public A\r\n{\r\n public: void dis()\r\n { \r\n  court&lt;&lt;a; \r\n }\r\n};\r\nclass C:private A\r\n{\r\n public void incr()\r\n {  a++; \r\n }\r\n}\r\nvoid main()\r\n{\r\n B b.disp();\r\n}",
        "A": " Compile time error",
        "B": "Runtime error",
        "C": "Program runs and o/p is 0",
        "D": "Program runs and o/p is garbage value",
        "Answer": "A",
        "Explanation": "The derived class D have not implemented the undefined function. Here the main concept involves hierarchical inheritance with abstract base class.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "How many classes can be derived from the base class using hierarchical inheritance? ",
        "A": "As many as required",
        "B": " Only 7",
        "C": " Only 3",
        "D": "Up to 127",
        "Answer": "A",
        "Explanation": "The number of classes that can be derived from a base class doesn’t have any restriction and hence will be able to derive as many classes as required. This feature gives more flexibility and code reusability.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "Which among the following is true ?        ",
        "A": " Hierarchical inheritance is subset of multiple inheritance",
        "B": " Hierarchical inheritance is strongest inheritance type",
        "C": "Hierarchical inheritance uses only 2 classes for implementation",
        "D": "Hierarchical inheritance allows inheritance of common features to more than one class",
        "Answer": "D",
        "Explanation": "Hierarchical inheritance is used to make all the inherited classes have some common features obtained from a single base class. This allows all the classes to maintain a group or to be classified under one class.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Hierarchical inheritance can be a subset of _________________   ",
        "A": "Hybrid inheritance ",
        "B": "Multiple inheritance",
        "C": "Single level inheritance",
        "D": "Multilevel inheritance",
        "Answer": "A",
        "Explanation": "When we use hybrid inheritance, it can contain any type of inheritance or combination or more than two types. Hence it may contain Hierarchical inheritance too, hence it can be subset of hybrid inheritance.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "Which type of inheritance is most suitable for inheriting Same syllabus into different colleges with different streams?      ",
        "A": "Multiple",
        "B": "Single",
        "C": "Hierarchical",
        "D": "Multilevel",
        "Answer": "C",
        "Explanation": " When hierarchical inheritance is used, the common syllabus can be adopted into different college classes where the same syllabus is applicable. For changing the syllabus only the details of base class will have to changed.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Which class constructor is called first when an object of derived class is created?            ",
        "A": " Base class constructor",
        "B": "Derived class constructor",
        "C": " Firstly created derived class constructor",
        "D": "Last created derived class constructor",
        "Answer": "A",
        "Explanation": "The base class must be initialised first hence the constructor of base class is called first. This makes everything ready for the new object being created.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "Which among the following defines single level inheritance?            ",
        "A": "One base class derives another class",
        "B": "One derived class inherits from one base class",
        "C": "One base class inherits from one derived class",
        "D": "One derived class derives from another derived class",
        "Answer": "B",
        "Explanation": "If only one base class is used to derive only one subclass, it is known as single level inheritance. The reason of this name is that we inherit the base class to one more level and stop the inheritance any further.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "If class A and class B are derived from class C and class D, then ________________             ",
        "A": "Those are 2 pairs of single inheritance",
        "B": "Those are 2 pairs of single inheritance",
        "C": "Those is enclosing class",
        "D": "Those are all independent classes",
        "Answer": "A",
        "Explanation": "Since class A is derived from class C and then class B is derived from class D, there are two pairs of classes which shows single inheritance. Those two pairs are independent of each other though.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "If single inheritance is used, program will contain ________________            ",
        "A": "At least 2 classes",
        "B": "At most 2 classes",
        "C": "Exactly 2 classes",
        "D": "At most 4 classes",
        "Answer": "A",
        "Explanation": " The program will contain at least 2 classes in the sense of base and derived classes. At least one base class and one derived class must be there. Types of inheritance remains the same though.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Single level inheritance supports _____________ inheritance.       ",
        "A": "Runtime",
        "B": "Compile time",
        "C": "Multiple inheritance",
        "D": "Language independency",
        "Answer": "A",
        "Explanation": "The runtime inheritance is done when object of a class is created to call a method. At runtime the function is searched if it is in class of object. If not, it will search in its parent classes and hierarchy for that method.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "Which method in the code below is single level inherited?     class A\r\n{\r\n protected int a, b;\r\n public: void show()\r\n { \r\n  cout&lt;&lt;a&lt;&lt;b;\r\n }\r\n};\r\nclass B: public A\r\n{\r\n public: void disp()\r\n { \r\n  cout&lt;&lt;a++&lt;&lt;b++; \r\n }\r\n}; class C: private A, public B\r\n{\r\n void avg()\r\n { \r\n  cout&lt;&lt;(a+b)/2; \r\n }\r\n};",
        "A": "Class A",
        "B": "Class B",
        "C": "Class C",
        "D": "None",
        "Answer": "B",
        "Explanation": "Class B is using single level inheritance. Class C is using multiple inheritance. And class A is parent of other two classes.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "If single level inheritance is used and an abstract class is created with some undefined functions, can its derived class also skip some definitions?    ",
        "A": "Yes, always possible",
        "B": "Yes, possible if only one undefined function",
        "C": "No, at least 2 undefined functions must be there",
        "D": "No, the derived class must implement those methods",
        "Answer": "D",
        "Explanation": "The derived class must implement those methods. This is because the parent class is abstract and hence will have some undefined functions which has to be defined in derived classes. Since we are using single level inheritance, if derived class doesn’t implement those functions then one more class has to be there which will become multi-level inheritance.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Which among the following is false for single level inheritance?        ",
        "A": "There can be more than 2 classes in program to implement single inheritance",
        "B": "There can be exactly 2 classes to implement single inheritance in a program",
        "C": "There can be more than 2 independent classes involved in single inheritance",
        "D": "The derived class must implement all the abstract method if single inheritance is used",
        "Answer": "C",
        "Explanation": "If more than 2 independent classes are involved to implement the single level inheritance, it won’t be possible as there must be only one child and one parent class and none other related class",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "Which concept will result in derived class with more features (consider maximum 3 classes)?",
        "A": "Single inheritance",
        "B": "Multiple inheritance",
        "C": "Multilevel inheritance",
        "D": "Hierarchical inheritance",
        "Answer": "B",
        "Explanation": " If single inheritance is used then only feature of a single class are inherited, and if multilevel inheritance is used, the 2nd class might have use private inheritance. Hence only multiple inheritance can result in derived class with more features. This is not mandatory but in a case if we consider same number of features in each class, it will result the same.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Single level inheritance is safer than _____________  ",
        "A": "Multiple inheritance",
        "B": "Interfaces",
        "C": "Implementations",
        "D": "Extensions",
        "Answer": "A",
        "Explanation": "Interfaces also represent a way of inheritance but is a wide word to decide which inheritance we are talking about in it, hence can’t be considered. Implementation and extensions also doesn’t match that level of specific idea. And multiple inheritance not so safe as it might result in some ambiguity.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "Which language doesn’t support single level inheritance?      ",
        "A": "Java",
        "B": "C++",
        "C": "Kotlin",
        "D": "All languages support it",
        "Answer": "D",
        "Explanation": "All the languages support single level inheritance. Since any class can inherit other classes as required, if single level inheritance was not allowed it would result in failing a lot of features of OOP.advertisement",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "Output of following program?   class A\r\n{\r\n protected: int a,b;\r\n public: void disp()\r\n { \r\n  cout&lt;&lt;a&lt;&lt;b; \r\n }\r\n};\r\nclass B:public A\r\n{\r\n int x,y;\r\n};",
        "A": "Garbage value",
        "B": "Compile time error",
        "C": "Runtime error",
        "D": "Runs but gives random values as output",
        "Answer": "B",
        "Explanation": "The compiler doesn’t find the main function and hence will throw an error main() missing. This program is using single level inheritance but the program is incomplete. Every program must implement main function.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "Output of following program?   class A\r\n{  \r\n float sal=40000;  \r\n}  \r\nclass B extends A\r\n{  \r\n int salBonus=10000;  \r\n public static void main(String args[])\r\n {  \r\n  B p=new B();  \r\n  System.out.println(\"B salary is:\"+p.sal);  \r\n  System.out.println(\"Bonus of B is:\"+p.bonus);  \r\n }  \r\n}",
        "A": "B salary is: 4000.0 Bonus of B is: 10000",
        "B": "B salary is 10000 Bonus of B is: 4000.0",
        "C": "Compile time error",
        "D": "Runtime error",
        "Answer": "A",
        "Explanation": "The program gives output as in option a. The program have used single level inheritance and hence have access to the parent class methods and variables. This program simply prints the value from parent class and from the child class.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "Single level inheritance will be best for___________    ",
        "A": "Inheriting a class which performs all the calculations",
        "B": "Inheriting a class which can print all the calculation results",
        "C": "Inheriting a class which can perform and print all calculations",
        "D": "Inheriting all the classes for different calculations",
        "Answer": "B",
        "Explanation": "Inheriting a class which can perform the most common task will be more efficient. If class which can perform all the calculations is inherited then there won’t be any problem to print the result too. But if a class which can do the most common task for all the other tasks, it will make real use of inheritance.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Which constructor will be called first from the classes involved in single inheritance from object of derived class?  ",
        "A": "Base class constructor",
        "B": "Derived class constructor",
        "C": "Both class constructors at a time",
        "D": "Runtime error",
        "Answer": "A",
        "Explanation": "The base class constructor will be called first from the object of derived class constructor. When the derived class members are to be initialized and allocated memory, the base class members should also be confirmed with the memory allocation.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "If base class contains 2 nested classes, will it be possible to implement single level inheritance?",
        "A": "Yes, always",
        "B": "Yes, only if derived class also have nested classes",
        "C": "No, it will use more than 2 classes which is wrong",
        "D": "No, never",
        "Answer": "A",
        "Explanation": "The nested classes are also members of a class. They behave as a used defined data type with some methods implementation. So the inheritance will be as usual with the nested classes being member of base class and of derived class if not private.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "Which among the following best defines multilevel inheritance?      ",
        "A": "A class derived from another derived class",
        "B": "Classes being derived from other derived classes",
        "C": "Continuing single level inheritance",
        "D": "Class which have more than one parent",
        "Answer": "B",
        "Explanation": "Only if the class is being derived from other derived class, it can be called as multilevel inheritance. If a class is derived from another class, it is single level inheritance. There must be more than one level of inheritance.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "If there are 5 classes, E is derived from D, D from C, C from B and B from A. Which class constructor will be called first if the object of E or D is created?    ",
        "A": "A",
        "B": "B",
        "C": "C",
        "D": "A and B",
        "Answer": "A",
        "Explanation": "A is parent of all other classes indirectly. Since A is parent of B and B is parent of C and so on till E. Class A constructor will be called first always.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "If there are 3 classes. Class C is derived from class B and B is derived from A, Which class destructor will be called at last if object of C is destroyed.     ",
        "A": "A",
        "B": "B",
        "C": "C",
        "D": "All together",
        "Answer": "A",
        "Explanation": "The destructors are called in the reverse order of the constructors being called. Hence in multilevel inheritance, the constructors are created from parent to child, which leads to destruction from child to parent. Hence class A destructor will be called at last.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Which Class is having highest degree of abstraction in multilevel inheritance of 5 levels?  ",
        "A": "Class at 1st level",
        "B": "Class 2nd last level",
        "C": "Class at 5th level",
        "D": "All with same abstraction",
        "Answer": "A",
        "Explanation": "The class with highest degree of abstraction will be the class at the 1st level. You can look at a simple example like, a CAR is more abstract than SPORTS CAR class. The level of abstraction decrease with each level as more details comes out.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "If all the classes use private inheritance in multilevel inheritance then ______________",
        "A": "It will not be called multilevel inheritance",
        "B": "Each class can access only non-private members of its parent",
        "C": "Each subsequent class can access all members of previous level parent classes",
        "D": "None of the members will be available to any other class",
        "Answer": "B",
        "Explanation": "The classes will be able to access only the non-private members of its parent class. The classes are using private inheritance, hence all the members of parent class become private in the derived class. In turn those won’t be allowed for further inheritance or direct access outside the class.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "Multilevel inheritance allows _________________ in the program.    ",
        "A": "Only 7 levels of inheritance",
        "B": "At least 7 levels of inheritance",
        "C": "At most 16 levels of inheritance",
        "D": "As many levels of inheritance as required",
        "Answer": "D",
        "Explanation": "The multilevel inheritance allows any number of levels of inheritance. This is the maximum flexibility feature to make the members available to all the new classes and to add their own functionalities. The code reusability is used too.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "What is minimum number of levels for a implementing multilevel inheritance?           ",
        "A": "1",
        "B": "2",
        "C": "3",
        "D": "4",
        "Answer": "C",
        "Explanation": "There must be at least 3 levels of inheritance. Otherwise if less, it will be single level inheritance or would have got no inheritance implemented. There must be a derived class from which another class is derived.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "In multilevel inheritance one class inherits _______________        ",
        "A": "Only one class",
        "B": "More than one class",
        "C": "At least one class",
        "D": "As many classes as required",
        "Answer": "A",
        "Explanation": "The classes inherit only from one class. This continues as each class inherits only one class. There should not be any class which inherits from two or more classes or which have more than one subclass.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "Can abstract classes be used in multilevel inheritance?   ",
        "A": "Yes, always",
        "B": "Yes, only one abstract class",
        "C": "No, abstract class doesn’t have constructors",
        "D": "No, never",
        "Answer": "A",
        "Explanation": "The abstract classes can always be used in multilevel inheritance. The only condition that may arise is that all the undefined functions must be defined in subclasses. There must not be any undefined function.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "How many abstract classes can be used in multilevel inheritance?  ",
        "A": "Only 1",
        "B": "Only 2",
        "C": "At least one less than number of levels",
        "D": " Can’t be used",
        "Answer": "C",
        "Explanation": "At least one class must implement all the undefined functions. Hence there must be at least one class which is not abstract. That is at least one less than number of levels.",
        "Difficulty": "1",
        "StID": "6"
    },
    {
        "Questions": "If all the classes used parameterized constructors and no default constructor then, __________",
        "A": "The object of lower level classes can’t be created",
        "B": "Object of lower level classes must call parent class constructors explicitly",
        "C": "Object of lower level classes must define all the default constructors",
        "D": "Only object of first class can be created, which is first parent",
        "Answer": "B",
        "Explanation": "Each class constructor must be called before creating object of any subclass. Hence it will be mandatory to call the constructors of parent classes explicitly with parameters. This will make all the previous class member be initialized and then the class in use will be able to create the object.advertisement",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "In multilevel inheritance, which is the most significant feature of OOP used? ",
        "A": "Code readability",
        "B": " Flexibility",
        "C": "Code reusability",
        "D": "Code efficiency",
        "Answer": "C",
        "Explanation": "The classes using multilevel inheritance will use the code in all the subsequent subclasses if available. Hence the most significant feature among the options given is code reusability. This feature is generally intended to use the data values and reuse the redundant functions.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "Does following code show multiple inheritance?   class A\r\n{\r\n int a;\r\n};\r\nclass B\r\n{\r\n int b;\r\n};\r\nclass C:public A, public B\r\n{\r\n int c;\r\n};\r\nclass D:public C\r\n{\r\n int d;\r\n};",
        "A": "Yes, class C and class D",
        "B": "Yes, All together it’s multilevel",
        "C": "No, 4 classes are used",
        "D": "No, multiple inheritance is used with class A, B and C",
        "Answer": "D",
        "Explanation": "Since multiple inheritance is used to derive class C and then class D is derived from class C. This is not multilevel inheritance. The classes should derive from single class. This is actually hybrid inheritance.",
        "Difficulty": "3",
        "StID": "6"
    },
    {
        "Questions": "Is it compulsory for all the classes in multilevel inheritance to have constructors defined explicitly if only last derived class object is created?   ",
        "A": "Yes, always",
        "B": "Yes, to initialize the members",
        "C": "No, it not necessary",
        "D": "No, Constructor must not be defined",
        "Answer": "C",
        "Explanation": "It’s not mandatory to define the constructors explicitly. Default constructor will always be provided by the compiler itself if none another constructor is defined in those classes. If explicit default constructor is defined it will be used.",
        "Difficulty": "2",
        "StID": "6"
    },
    {
        "Questions": "What is  an exception?",
        "A": "Problem arising during compile time",
        "B": "Problem arising during runtime",
        "C": "Problem in syntax",
        "D": "Problem in IDE",
        "Answer": "B",
        "Explanation": "The problems that might occur during execution of a program are known as exceptions. The exceptions are unexpected sometimes and can be predicted. Also, the exceptions should be always considered for a better program.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "Why do we need to handle exceptions?",
        "A": "To prevent abnormal termination of program",
        "B": "To encourage exception prone program",
        "C": "To avoid syntax errors",
        "D": "To save memory",
        "Answer": "A",
        "Explanation": "The exceptions should be handled to prevent any abnormal termination of a program. The program should keep running even if it gets interrupted in between. The program should preferable show the error occurred and then retry the process or just continue the program further.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "An exception may arise when _______________     ",
        "A": "Input is fixed",
        "B": "Input is some constant value of program",
        "C": "Input given is invalid",
        "D": "Input is valid",
        "Answer": "C",
        "Explanation": "The exceptions may arise because the input given by the user might not be of the same type that a program can manage. If the input is invalid the program gets terminated.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "If a file that needs to be opened is not found in the target location then _____________   ",
        "A": "Exception will be produced",
        "B": "Exceptions are not produced",
        "C": "Exception might get produced because of syntax",
        "D": "Exceptions are not produced because of logic",
        "Answer": "A",
        "Explanation": "The exceptions are produced when anything unexpected happened. The program might not be able to find a file in the target location and hence program produces an exceptions. The exception produced, then terminates the program.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "Which is the universal exception handler class?      ",
        "A": "Object",
        "B": " Math",
        "C": "Errors",
        "D": "Exceptions",
        "Answer": "D",
        "Explanation": "Any type of exception can be handled by using class Exceptions. An object of this class is created which can manipulate the exception data. The data can be used to display the error or to run the program further based on error produced.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "What are two exception classes in hierarchy of java exceptions class? ",
        "A": "Runtime exceptions only",
        "B": "Compile time exceptions only",
        "C": "Runtime exceptions and other exceptions",
        "D": "Other exceptions",
        "Answer": "C",
        "Explanation": "The exceptions class is having two other derived classes which are of runtime exception handler and for other type of exceptions handling. The runtime exception handler is used to handle the exceptions produced during run time and same with case of other exceptions.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "Which are the two blocks that are used to check error and handle the error? ",
        "A": "Try and catch",
        "B": "Trying and catching",
        "C": "Do and while",
        "D": " TryDo and Check",
        "Answer": "A",
        "Explanation": "Two blocks that are used to check for errors and to handle the errors are try and catch block. The code which might produce some exceptions is placed inside the try block and then the catch block is written to catch the error that is produced. The error message or any other processing can be done in catch block if the error is produced.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "How many catch blocks can a single try block can have?     ",
        "A": "Only 1",
        "B": "Only 2",
        "C": "Maximum 127",
        "D": "As many as required",
        "Answer": "D",
        "Explanation": "There is no limit on the number of catch blocks corresponding to a try block. This is because the error can be of any type and for each type, a new catch block can be defined. This is to make sure all type of exceptions can be handled.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "Which among the following is not a method of Throwable class?     ",
        "A": "public String getMessage()",
        "B": " public Throwable getCause()",
        "C": "public Char toString()",
        "D": "public void printStackTrace()",
        "Answer": "C",
        "Explanation": "Actually all the functions are available in throwable class. But the return type given in the option is wrong. The function toString returns string value. Hence the return type must be a String and not a char.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "To catch the exceptions ___________________        ",
        "A": "An object must be created to catch the exception",
        "B": "A variable should be created to catch the exception",
        "C": "An array should be created to catch all the exceptions",
        "D": "A string have to be created to store the exception",
        "Answer": "A",
        "Explanation": " The object must be created of a specific class of which the error has occurred. If the type of error is unknown then we can use an object of class Exceptions. This object will be able to handle any kind of exception that a program might produce.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "Multiple catch blocks __________________   ",
        "A": "Are mandatory for each try block",
        "B": " Can be combined into a single catch block",
        "C": "Are not possible for a try block",
        "D": "Can never be associated with a single try block",
        "Answer": "B",
        "Explanation": "The separate catch blocks for a single try block can be combined into a single catch block. All type of errors can be then handled in s single block. The type still have to be specified for the errors that might be produced.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "Which symbol should be used to separate the type of exception handler classes in a single catch block?       ",
        "A": "?",
        "B": ",",
        "C": "–",
        "D": "|",
        "Answer": "D",
        "Explanation": "A pipe symbol can be used to separate different type of exceptions. The exceptions should always be given in proper sequence to ensure that no code remains unreachable. If not done properly the code might never be used in a program.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "Which class is used to handle the input and output exceptions?     ",
        "A": "InputOutput",
        "B": "InputOutputExceptions",
        "C": "IOExceptions",
        "D": "ExceptionsIO",
        "Answer": "C",
        "Explanation": "There is a specific class to handle each type of exceptions that might be produced in a program. The input and output exceptions can be handled by an object of class IOExcceptions. This class handles all type of input and output exceptions.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "Why do we use finally block?    ",
        "A": "To execute the block if exception occurred",
        "B": "To execute a code when exception is not occurred",
        "C": "To execute a code whenever required",
        "D": "To execute a code with each and every run of program",
        "Answer": "D",
        "Explanation": "Sometimes there is a need to execute a set of code every time the program runs. Even if the exception occurs and even if it doesn’t, there can be some code that must be executed at end of the program. That code is written in finally block. This block is always executed regardless of exceptions occurring.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "Which among the following best defines static variables members?     ",
        "A": "Data which is allocated for each object separately",
        "B": "Data which is common to all the objects of a class",
        "C": "Data which is common to all the classes",
        "D": "Data which is common to a specific method",
        "Answer": "B",
        "Explanation": "The static data members are made common to all the object of a class. They doesn’t change from object to object. Those are property of class rather than of any individual object.",
        "Difficulty": "3",
        "StID": "7"
    },
    {
        "Questions": "Which keyword should be used to declare static variables?      ",
        "A": "static",
        "B": "stat",
        "C": " common",
        "D": "const",
        "Answer": "A",
        "Explanation": "The keyword used to declare static variables is static. This is must be used while declaring the static variables. The compiler can make variables static if and only if they are mentioned with static keyword.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "Any changes made to static data member from one member function ____________",
        "A": "Is reflected to only the corresponding object",
        "B": "Is reflected to all the variables in a program",
        "C": "Is reflected to all the objects of that class",
        "D": "Is constant to that function only",
        "Answer": "C",
        "Explanation": "The changes made from any function to static data member will be a common change for all the other objects also. If the change is made with respect to one object and change is printed from another object, the result will be same.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "Which is the correct syntax for declaring static data member?   ",
        "A": "static mamberName dataType;",
        "B": "dataType static memberName;",
        "C": "memberName static dataType;",
        "D": "static dataType memberName;",
        "Answer": "D",
        "Explanation": "The syntax must firstly be mentioned with the keyword static. Then the data type of the member followed by the member name should be given. This is general form of declaring static data members.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "The static data member ______________________        ",
        "A": "Must be defined inside the class",
        "B": "Must be defined outside the class",
        "C": " Must be defined in main function",
        "D": "Must be defined using constructor",
        "Answer": "B",
        "Explanation": "The static data members must be defined outside the class. Since these are common to all the objects and should be created only once, they must not be defined in the constructor.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "The syntax for defining the static data members is:   ",
        "A": "dataType className :: memberName =value;",
        "B": "dataType className : memberName =value;",
        "C": "dataType className . memberName =value;",
        "D": "dataType className -> memberName =value;",
        "Answer": "A",
        "Explanation": "The syntax doesn’t contain the static keyword. Since it is already been declared as static inside the class. The data type and the corresponding class name must be there to allocate the variable to a class. The value is assigned using scope resolution operator for the member name.",
        "Difficulty": "3",
        "StID": "7"
    },
    {
        "Questions": "If static data members have to be used inside a class, those member functions _____________",
        "A": " Must not be static member functions",
        "B": " Must not be member functions",
        "C": "Must be static member functions",
        "D": "Must not be member function of corresponding class",
        "Answer": "C",
        "Explanation": "Only the static member functions can access the static data members. The definition of static members is made common and hence the member function should be capable of manipulating the static data members.",
        "Difficulty": "3",
        "StID": "7"
    },
    {
        "Questions": "The static data member __________________________      ",
        "A": "Can be accessed directly",
        "B": "Can be accessed with any public class name",
        "C": "Can be accessed with dot operator",
        "D": "Can be accessed using class name if not using static member function",
        "Answer": "D",
        "Explanation": "The static data members can be accessed using the class name also. If the member functions is not used or is not to be used then we can call the static data members directly by using its corresponding class name.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "Which among the following is correct syntax to access static data member without using member function?      ",
        "A": " className -> staticDataMember;",
        "B": "className :: staticDataMember;",
        "C": "className : staticDataMember;",
        "D": "className . staticDataMember;",
        "Answer": "B",
        "Explanation": "For accessing the static data members without using the static member functions, the class name can be used. The class name followed by scope resolution, indicating that static data members is member of this class, and then the data member name.",
        "Difficulty": "3",
        "StID": "7"
    },
    {
        "Questions": "Which data members among the following are static by default?      ",
        "A": " extern",
        "B": "integer",
        "C": "const",
        "D": "void",
        "Answer": "C",
        "Explanation": "The const data members of any class are made static by default. This is an implicit meaning given by the compiler to the member. Since const values won’t change from object to object, hence are made static instead.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "What is the output of the following program?    class Test\r\n{\r\n private: static int x;\r\n public: static void fun()\r\n {\r\n  cout &lt;&lt; ++x &lt;&lt; “ ”;\r\n }\r\n};\r\nint Test :: x =20;\r\nvoid main() {\r\n Test x;\r\n x.fun();\r\n x.fun();\r\n}",
        "A": "20 22",
        "B": " 20 21",
        "C": "21 22",
        "D": "22 23",
        "Answer": "C",
        "Explanation": "The static member is initialized with 20. Then the function is called which used pre-increment and printed value of x. The function is called twice. Hence we get 21 22 as output.advertisement",
        "Difficulty": "3",
        "StID": "7"
    },
    {
        "Questions": "Whenever any static data member is declared in a class ____________________",
        "A": "Only one copy of the data is created",
        "B": "New copy for each object is created",
        "C": "New memory location is allocated with each object",
        "D": "Only one object uses the static data",
        "Answer": "A",
        "Explanation": "The static data is same for all the objects. Instead of creating the same data each time an object is created, the compiler created only one data which is accessed by all the objects of the class. This saves memory and reduces redundancy.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "If object of class are created, then the static data members can be accessed ___________",
        "A": "Using dot operator",
        "B": "Using arrow operator",
        "C": "Using colon",
        "D": "Using dot or arrow operator",
        "Answer": "D",
        "Explanation": "The static data members can be accessed in usual way as other members are accessed using the objects. The dot operator is used generally. Arrow can be used with the pointers.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "What will be the output of the following program?  class Test\r\n{\r\n public: Test() \r\n { \r\n  cout  &lt;&lt; \"Test's Constructor is Called \" &lt;&lt; endl;  \r\n }\r\n};\r\n \r\nclass Result\r\n{\r\n static Test a;\r\n public:\r\n Result() \r\n { \r\n  cout  &lt;&lt; \"Result's Constructor is Called \" &lt;&lt; endl; \r\n }\r\n}; \r\n \r\nvoid main() \r\n{ \r\n Result b; \r\n}",
        "A": "Test’s Constructor is Called",
        "B": "Result’s Constructor is Called",
        "C": "Result’s Constructor Called Test’s Constructor is Called",
        "D": "Test’s Constructor Called Result’s Constructor is Called",
        "Answer": "B",
        "Explanation": "The output is the message printed from the constructor of class Result. There is no inheritance used hence only one constructor is called. Since static members are declared once in class declaration and are not defined. The constructor of class Test will not be called.",
        "Difficulty": "3",
        "StID": "7"
    },
    {
        "Questions": "Which among the following is wrong syntax related to static data members?  ",
        "A": "className :: staticDataMember;",
        "B": "dataType className :: memberName =value;",
        "C": "static dataType memberName;",
        "D": "className : dataType -> memberName;",
        "Answer": "D",
        "Explanation": "he syntax given in option d doesn’t belong to any particular declaration or definition. First one is to access the static members using the class name. Second is to define the static data outside the class. Third syntax id to declare a data member as static in a class.",
        "Difficulty": "3",
        "StID": "7"
    },
    {
        "Questions": "Which among the following is true for class exceptions?       ",
        "A": "Only base class can give rise to exceptions",
        "B": "Only derived class can give rise to exceptions",
        "C": "Either base class or derived class may produce exceptions",
        "D": "Both base class and derived class may produce exceptions",
        "Answer": "D",
        "Explanation": "It’s not mandatory that either base class or derived class can give rise to exceptions. The exceptions might get produced from any class. The exceptions depends on code.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "If both base and derived class caught exceptions ______________",
        "A": "Then catch block of derived class must be defined before base class",
        "B": "Then catch block of base class must be defined before the derived class",
        "C": "Then catch block of base and derived classes doesn’t matter",
        "D": "Then catch block of base and derived classes are not mandatory to be defined",
        "Answer": "A",
        "Explanation": "It is a condition for writing the catch blocks for base and derived classes. It is mandatory to write derived class catch block first because the errors produced by the derived class must be handled first.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "Which among the following is true?      ",
        "A": "If catch block of base class is written first, it is compile time error",
        "B": "If catch block of base class is written first, it is run time error",
        "C": "If catch block of base class is written first, derived class catch block can’t be reached",
        "D": "If catch block of base class is written first, only derived class catch block is executed",
        "Answer": "C",
        "Explanation": "If the catch block of the base class is defined first and then the derived class catch block is given. The code becomes unreachable. Hence the derived class catch block must be written first.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "The catching of base class exception ___________________________ in java.    ",
        "A": "After derived class is not allowed by compiler",
        "B": "Before derived class is not allowed by compiler",
        "C": "Before derived class is allowed",
        "D": "After derived class can’t be done",
        "Answer": "B",
        "Explanation": "The catching of base class exception before derived class is not allowed in java. The compiler itself doesn’t allow this declaration. It produces an error.",
        "Difficulty": "3",
        "StID": "7"
    },
    {
        "Questions": "If catching of base class exception is done before derived class in C++ ________________ ",
        "A": "It gives compile time error",
        "B": "It doesn’t run the program",
        "C": "It may give warning but not error",
        "D": "It always gives compile time error",
        "Answer": "C",
        "Explanation": "The compiler in C++ doesn’t identify this as compile time error and allows the execution of the program. But, the compiler may give some warning related to the catch block sequence or code unreachable.",
        "Difficulty": "3",
        "StID": "7"
    },
    {
        "Questions": "How many catch blocks can a class have?   ",
        "A": "Only 1",
        "B": "2",
        "C": "3",
        "D": "As many as required",
        "Answer": "D",
        "Explanation": "There are many type of exceptions that may arise while running a code. And each catch block can handle only one exception. Hence there can be as many catch blocks as required.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "Since which version of java is multiple exception catch was made possible?   ",
        "A": "Java 4",
        "B": "Java 5",
        "C": "Java 6",
        "D": "Java 7",
        "Answer": "D",
        "Explanation": "None of the languages used to support multiple exception catch in a single catch block. Since java 7 the feature was added to catch more than one exceptions in one catch block.487",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "To catch more than one exception in one catch block, how are the exceptions separated in the syntax?",
        "A": "Vertical bar",
        "B": "Hyphen",
        "C": "Plus",
        "D": "Modulus",
        "Answer": "A",
        "Explanation": "Just the way we separate the arguments in a function definition using comma. Here we separate the exceptions by using a vertical bar or we call it pipe symbol sometimes. This is just a convention followed to separate different exception list.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "If a catch block accepts more than one exceptions then ______________",
        "A": " The catch parameters are not final",
        "B": "The catch parameters are final",
        "C": "The catch parameters are not defined",
        "D": " The catch parameters are not used",
        "Answer": "B",
        "Explanation": "The catch parameters are made final. This is to ensure that the parameters are not changed inside the catch block. Hence those retain their values.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "Which among the following handles the undefined class in program? ",
        "A": "ClassNotFound",
        "B": "NoClassException",
        "C": "ClassFoundException",
        "D": "ClassNotFoundException",
        "Answer": "D",
        "Explanation": "It is the exception handler that handles the exceptions when the class used is not found in the program. This is done to handle all the undefined class exceptions. This can be due to a command line error.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "If classes produce some exceptions, then ______________________  ",
        "A": "Their respective catch block must be defined",
        "B": "Their respective catch blocks are not mandatory",
        "C": "Their catch blocks should be defined inside main function",
        "D": "Their catch blocks must be defined at the end of program",
        "Answer": "A",
        "Explanation": "The catch blocks must be defined. This is to ensure that all the exceptions related to the classes are handled by the program code and the program doesn’t terminate unexpectedly",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "Which among the following is true?  ",
        "A": "Only the base class catch blocks are important",
        "B": "Only the derived class catch blocks are important",
        "C": "Both the base and derived class catch blocks are important",
        "D": "If base and derived classes both produce exceptions, program doesn’t run",
        "Answer": "C",
        "Explanation": "The purpose of exception handling is to handle the unexpected errors in the program. If base class might produce some error then its catch block must be given and if the derived class might produce some error then it must be given a specific catch block too.",
        "Difficulty": "3",
        "StID": "7"
    },
    {
        "Questions": "Which is the necessary condition to define the base and derived class catch blocks? ",
        "A": " Base class catch should be defined first",
        "B": "Derived class catch should be defined first",
        "C": "Catch block for both the classes must not be defined",
        "D": "Catch block must be defined inside main function",
        "Answer": "B",
        "Explanation": "The derived class catch blocks must be defined prior to the base class catch block. This is to ensure that all the catch boxes are reachable. If not done, the code might become unreachable which in turn makes the program prone to errors.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "Which condition among the following might result in memory exception? ",
        "A": "False if conditions",
        "B": "Nested if conditions that are all false",
        "C": "Infinite loops",
        "D": "Loop that runs exactly 99 times",
        "Answer": "C",
        "Explanation": "The infinite loops doesn’t stop running once started. There must be a way to stop the loop but that is always an improper termination. Infinite loops may keep on using more memory and hence would result in memory error.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "Which among the following is correct definition for static member functions?     ",
        "A": "unctions created to allocate constant values to each object",
        "B": "Functions made to maintain single copy of member functions for all objects",
        "C": "Functions created to define the static members",
        "D": "Functions made to manipulate static programs",
        "Answer": "B",
        "Explanation": "The functions which are made common, with respect to definition and data usage, to all the objects. These functions are able to access the static data members of a class.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "The static member functions __________________    ",
        "A": "Have access to all the members of a class",
        "B": "Have access to only constant members of a class",
        "C": "Have access to only the static members of a class",
        "D": "Have direct access to all other class members also",
        "Answer": "C",
        "Explanation": "The static member functions are common for all the objects. These functions can use only the static members of a class in which those are defined. This is because other members change with respect to each object created.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "The static member functions ____________________   ",
        "A": " Can be called using class name",
        "B": "Can be called using program name",
        "C": "Can be called using program name",
        "D": "Can’t be called outside the function",
        "Answer": "A",
        "Explanation": "The static members can be accessed using class name also. This is because the static members remain common to all the objects. Hence objects are not required.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "Which is correct syntax to access the static member functions with class name?   ",
        "A": "className . functionName;",
        "B": " className -> functionName;",
        "C": "className : functionName;",
        "D": "className :: functionName;",
        "Answer": "D",
        "Explanation": "The scope resolution operator must be used to access the static member functions with class name. This indicates that the function belongs to the corresponding class.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "Which among the following is not applicable for the static member functions?     ",
        "A": "Variable pointers",
        "B": "void pointers",
        "C": "this pointer",
        "D": "Function pointers",
        "Answer": "C",
        "Explanation": "Since the static members are not property of objects, they doesn’t have this pointer. Every time the same member is referred from all the objects, hence use of this pointer is of no use.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "Which among the following is true?     ",
        "A": "Static member functions can’t be virtual",
        "B": "Static member functions can be virtual",
        "C": " Static member functions can be declared virtual if it is pure virtual class",
        "D": "Static member functions can be used as virtual in Java",
        "Answer": "A",
        "Explanation": " The static member functions can’t be virtual. This is a restriction on static member functions, since the definition should not change or should not be overridden by any other function of derived class. The static members must remain same for all the objects.",
        "Difficulty": "3",
        "StID": "7"
    },
    {
        "Questions": "The static members are ______________________     ",
        "A": "Created with each new object",
        "B": "Created twice in a program",
        "C": "Created as many times a class is used",
        "D": "Created and initialized only once",
        "Answer": "D",
        "Explanation": "The static members are created only once. Then those members are reused whenever called or invoked. Memory is allocated only once.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "Which among the following is true?    ",
        "A": "Static member functions can be overloaded",
        "B": "Static member functions can’t be overloaded",
        "C": "Static member functions can be overloaded using derived classes",
        "D": "Static member functions are implicitly overloaded",
        "Answer": "B",
        "Explanation": "The static member functions can’t be overloaded because the definition must be the same for all the instances of a class. If an overloaded function have many definitions, none of them can be made static.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "The static member functions _______________         ",
        "A": "Can’t be declared const",
        "B": "Can’t be declared volatile",
        "C": "Can’t be declared const or volatile",
        "D": "Can’t be declared const, volatile or const volatile",
        "Answer": "D",
        "Explanation": " The static member functions can’t be made const, since any object or class itself should be capable of making changes to the function. And the function must retain all changes common to all the objects.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "Which keyword should be used to declare the static member functions?           ",
        "A": "static",
        "B": "stat",
        "C": " const",
        "D": " common",
        "Answer": "A",
        "Explanation": "The member functions which are to be made static, must be preceded with the keyword static. This indicates the compiler to make the functions common to all the objects. And a new copy is not created with each of the new object.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "The keyword static is used _______________       ",
        "A": "With declaration inside class and with definition outside the class",
        "B": "With declaration inside class and not with definition outside the class",
        "C": "With declaration and definition wherever done",
        "D": "With each call to the member function",
        "Answer": "B",
        "Explanation": "The keyword is used only inside the class while declaring the static member. Outside the class, only definition with proper syntax is given. There is no need of specifying the keyword static again.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "Which among the following can’t be used to access the members in any way?  ",
        "A": "Scope resolution",
        "B": "Arrow operator",
        "C": " Single colon",
        "D": "Dot operator",
        "Answer": "C",
        "Explanation": " The single colon can’t be used in any way in order to access the static members of a class. Other symbols can be used according to the code and need.",
        "Difficulty": "1",
        "StID": "7"
    },
    {
        "Questions": "We can use the static member functions and static data member __________________      ",
        "A": "Even if class object is not created",
        "B": "Even if class is not defined",
        "C": " Even if class doesn’t contain any static member",
        "D": "Even if class doesn’t have complete definition",
        "Answer": "A",
        "Explanation": "The static members are property of class as a whole. There is no need of specific objects to call static members. Those can be called directly or with class name.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "The static data member _________________  ",
        "A": " Can be mutable",
        "B": " Can’t be mutable",
        "C": "Can’t be integer",
        "D": "Can’t be characters",
        "Answer": "B",
        "Explanation": "The static data members can never be mutable. There copies are not made. Since those are common and created only once.",
        "Difficulty": "2",
        "StID": "7"
    },
    {
        "Questions": "If static data member are made inline, ______________    ",
        "A": "Those should be initialized outside the class",
        "B": "Those can’t be initialized with the class",
        "C": "Those can be initialized within the class",
        "D": "Those can’t be used by class members",
        "Answer": "C",
        "Explanation": "Since the members are created once and are common for all the instances, those can be initialized inside the class. Those doesn’t change with each object being created hence can be defined inside the class once for all.",
        "Difficulty": "3",
        "StID": "7"
    },
    {
        "Questions": "Passing object to a function _______________     ",
        "A": "Can be done only in one way",
        "B": " Can be done in more than one ways",
        "C": "Is not possible",
        "D": "Is not possible in OOP",
        "Answer": "B",
        "Explanation": "The objects can be passed to the functions and this requires OOP concept because objects are main part of OOP. The objects can be passed in more than one way to a function. The passing depends on how the object have to be used.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "The object ________________       ",
        "A": "Can be passed by reference",
        "B": " Can be passed by value",
        "C": "Can be passed by reference or value",
        "D": "Can be passed with reference",
        "Answer": "C",
        "Explanation": "The objects can be passed by reference if required to use the same object. The values can be passed so that the main object remains same and no changes are made to it if the function makes any changes to the values being passed.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "Which symbol should be used to pass the object by reference in C++? ",
        "A": "&",
        "B": "@",
        "C": "$",
        "D": "$ or &",
        "Answer": "A",
        "Explanation": " The object to be passed by reference to the function should be preceded by & symbol in the argument list syntax of the function. This indicates the compiler not to use new object. The same object which is being passed have to be used.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "If object is passed by value, ________________     ",
        "A": "Copy constructor is used to copy the values into another object in the function",
        "B": "Copy constructor is used to copy the values into temporary object",
        "C": "Reference to the object is used to access the values of the object",
        "D": "Reference to the object is used to created new object in its place",
        "Answer": "A",
        "Explanation": "The copy constructor is used. This constructor is used to copy the values into a new object which will contain all the values same as that of the object being passed but any changes made to the newly created object will not affect the original object.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "Pass by reference of an object to a function _______________    ",
        "A": "Affects the object in called function only",
        "B": "Affects the object in prototype only",
        "C": "Affects the object in caller function",
        "D": "Affects the object only if mentioned with & symbol with every call",
        "Answer": "C",
        "Explanation": "The original object in the caller function will get affected. The changes made in the called function will be same in the caller function object also.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "Copy constructor definition requires __________________     ",
        "A": "Object to be passed by value",
        "B": "Object not to be passed to it",
        "C": "Object to be passed by reference",
        "D": "Object to be passed with each data member value",
        "Answer": "C",
        "Explanation": "The object must be passed by reference to a copy constructor. This is to avoid the out of memory error. The constructors keeps calling itself, if not passed by reference, and goes out of memory.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "What is the type of object that should be specified in argument list?       ",
        "A": "Function name",
        "B": " Object name itself",
        "C": "Caller function name",
        "D": "Class name of object",
        "Answer": "D",
        "Explanation": "The type of object is the class itself. The class name have to be specified in order to pass the objects to a function. This allows the program to create another object of same class or to use the same object that was passed.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "If an object is passed by value, _________________   ",
        "A": "Temporary object is used in the function",
        "B": " Local object in the function is used",
        "C": "Only the data member values are used",
        "D": "The values are accessible from the original object",
        "Answer": "B",
        "Explanation": " When an object is called by values, copy constructor is called and object is copied to the local object of the function which is mentioned in the argument list. The values gets copied and are used from the local object. There is no need to access the original object again.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "Can data members be passed to a function using the object?      ",
        "A": " Yes, it can be passed only inside class functions",
        "B": "Yes, only if the data members are public and are being passed to a function outside the class",
        "C": "No, can’t be passed outside the class",
        "D": "No, can’t be done",
        "Answer": "B",
        "Explanation": "The data members can be passed with help of object but only if the member is public. The object will obviously be used outside the class. The object must have access to the data member so that its value or reference is used outside the class which is possible only if the member is public.",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "What exactly is passed when an object is passed by reference?           ",
        "A": "The original object name",
        "B": "The original object class name",
        "C": "The exact address of the object in memory",
        "D": "The exact address of data members",
        "Answer": "C",
        "Explanation": "The location of the object, that is, the exact memory location is passed, when the object is passed by reference. The pass by reference is actually a reference to the object that the function uses with another name to the same memory location as the original object uses.",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "If the object is not to be passed to any function but the values of the object have to be used then:",
        "A": "The data members should be passed separately  ",
        "B": "The data members and member functions have to be passed separately",
        "C": "The values should be present in other variables",
        "D": "The object must be passed",
        "Answer": "A",
        "Explanation": "The data members can be passed separately. There is no need to pass whole object, instead we can use the object to pass only the required values.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "Which among the following is true?    ",
        "A": "More than one object can’t be passed to a function",
        "B": "Any number of objects can be passed to a function",
        "C": "Objects can’t be passed, only data member values can be passed",
        "D": "Objects should be passed only if those are public in class",
        "Answer": "B",
        "Explanation": "There is no restriction on passing the number of objects to a function. The operating system or the compiler or environment may limit the number of arguments. But there is no limit on number of objects till that limit.advertisement",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "What will be the output if all necessary code is included (Header files and main function)?void test (Object &y)\r\n{\r\n    y = \"It is a string\";\r\n}\r\nvoid main()\r\n{\r\n Object x = null;\r\n test (x);\r\n System.out.println (x);\r\n}",
        "A": "Run time error",
        "B": "Compile time error",
        "C": "Null",
        "D": "It is a string",
        "Answer": "D",
        "Explanation": "In which type is new memory location will be allocated?  ",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "In which of the following way(s) can the object be returned from a function? ",
        "A": "Can only be returned by value",
        "B": "Can only be returned by reference",
        "C": "Can be returned either by value or reference",
        "D": "Can neither be returned by value nor by reference",
        "Answer": "C",
        "Explanation": "The objects can be returned either by value or reference. There is no mandatory condition for the way it should be used. The way of returning object can be decided based on the requirement.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "Whenever an object is returned by value ____________________ ",
        "A": "A temporary object is created",
        "B": "Temporary object is not created",
        "C": "Temporary object may or may not be created",
        "D": "New permanent object is created",
        "Answer": "A",
        "Explanation": "A temporary object is created when an object is returned by value. The temporary object is used to copy the values to another object or to be used in some way. The object holds all the values of the data members of the object.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "Where the temporary objects (created while return by value) are created? ",
        "A": "Outside the function scope",
        "B": "Within the function",
        "C": " Inside the main function",
        "D": "Inside the calling function",
        "Answer": "B",
        "Explanation": "The temporary object are created within the function and are intended to return the value for specific use. Either the object can be assigned to another object or be used directly if possible.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "Which is the correct syntax for returning an object by value? ",
        "A": "void functionName ( ){ }",
        "B": "object functionName( ) { }",
        "C": "class object functionName( ) { }",
        "D": "ClassName functionName ( ){ }",
        "Answer": "D",
        "Explanation": "The class name itself should be the return type of the function. This notifies that the function will return an object of specified class type. Only the class name should be specified.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "Which is the correct syntax for defining a function which passes an object by reference?             ",
        "A": "className& functionName ( )",
        "B": "className* functionName( )",
        "C": "className-> functionName( )",
        "D": "&className functionName()",
        "Answer": "A",
        "Explanation": "The function declaration must contain the class name as return type. But, a & symbol should be followed by the class name. & indicates that the object being returned will be returned by reference.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "If an object is declared inside the function then ____________________ outside the function  ",
        "A": "It can be returned by reference",
        "B": " It can’t be returned by reference",
        "C": "It can be returned by address",
        "D": "It can’t be returned at all",
        "Answer": "B",
        "Explanation": "The object which is declared inside the class can never be returned by reference. This is because the object will be destroyed as it goes out of scope when the function is returned. The local variables get destroyed when function is returned hence the local objects can’t be returned by reference.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "How many independent objects can be returned at same time from a function?  ",
        "A": "1",
        "B": "2",
        "C": "3",
        "D": "4",
        "Answer": "A",
        "Explanation": "Only one object can be returned at a time. This is because a function is only capable of returning a single value at a time. Though array of objects can be returned from a function.",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "Which error will be produced if a local object is returned by reference outside a function?   ",
        "A": "Out of memory error",
        "B": "Run time error",
        "C": "Compile time error",
        "D": "No error",
        "Answer": "C",
        "Explanation": "If the local object is returned outside the function then the compile-time error arises. While the program is being converted and the processes happening during compile time, the compiler won’t be able to resolve the statement.",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "If object is passed by reference ____________________     ",
        "A": " Temporary object is created",
        "B": "Temporary object is created inside the function",
        "C": "Temporary object is created for few seconds",
        "D": "Temporary object is not created",
        "Answer": "D",
        "Explanation": "The temporary object is not created. If object is returned by reference, a particular memory location will be denoted with another name and hence same address values will be used.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "Which among the following is correct?       ",
        "A": "Individual data members can’t be returned",
        "B": "Individual data members can be returned",
        "C": "Individual member functions can be returned from another function",
        "D": "Individual data members can only be passed by reference",
        "Answer": "B",
        "Explanation": "It is not mandatory to return the whole object. Instead we can return a specific data member value. But the return type given must match with the data type of the data being returned.",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "Can we return an array of objects?    ",
        "A": "Yes, always",
        "B": "Ye, only if objects are having same values",
        "C": "No, because objects contain many other values",
        "D": "No, because objects are single entity",
        "Answer": "A",
        "Explanation": "The Object array can be returned from a function. This can be done by putting a className* as the return type of the function. This makes the return type to accept an array of objects in return.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "Which among the following is true?       ",
        "A": "Two objects can point to the same memory location",
        "B": "Two objects can never point to the same memory location",
        "C": "Objects not allowed to point at a location already occupied",
        "D": "Objects can’t point to any address",
        "Answer": "A",
        "Explanation": "When an object is created and instead of calling a constructor, another object is assigned to it. Both the objects point to the same memory location. This can be illustrated with help of return by reference.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "If an object is being returned by value then _________________________",
        "A": "Its member values are made constant",
        "B": "Its member values have to be copied individually",
        "C": "Its member values are not used",
        "D": "Its member values are copied using copy constructor",
        "Answer": "D",
        "Explanation": "When an object is returned by value, it will be returned to another object or will be directly used. Still in all the conditions the copy constructor will be used to copy all the values from the temporary object that gets created.",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "Why temporary object is not created in return by reference?    ",
        "A": "Because compiler can’t create temporary objects",
        "B": "Because the temporary object is created within the function",
        "C": "Because return by reference just make the objects points to values memory location",
        "D": "Because return by reference just make the object point to null",
        "Answer": "C",
        "Explanation": "A reference to the memory location where the returned object is stored is made. This allows the new object which takes the return value, point to the memory location and hence access the same values.",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "When value of an object is assigned to another object, ________________",
        "A": "It becomes invalid statement",
        "B": "Its values gets copied into another object",
        "C": "Its values gets address of the existing values",
        "D": "The compiler doesn’t execute that statement",
        "Answer": "B",
        "Explanation": "The values get copied to another object. No address is assigned to the object values. This is uses copy constructor to copy the values.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "If an object is created and another object is assigned to it, then ______________",
        "A": "Copy constructor is called to copy the values",
        "B": " Object is copied directly to the object",
        "C": "Reference to another object is created",
        "D": "The new object is initialized to null values",
        "Answer": "C",
        "Explanation": "The new object created, refers to the same address of the previously created object. Now whenever new object changes any data member value, it will affect the previously existing object.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "How the argument passed to a function get initialized?            ",
        "A": "Assigned using copy constructor at time of passing",
        "B": "Copied directly",
        "C": "Uses addresses always",
        "D": "Doesn’t get initialized",
        "Answer": "A",
        "Explanation": "The arguments get initialized using the copy constructor. There is need of assigning the value of all the members of an object to the local object of the function.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "Predict the output of the program.    class A\r\n{\r\n public int i;\r\n};\r\nvoid main()\r\n{\r\n A x;\r\n A y=x;\r\n x.i=10;\r\n y.i=20;\r\n y.i++;\r\n y.i=20;\r\n cout&l;&lt;tx.i;\r\n}",
        "A": "10",
        "B": "20",
        "C": "21",
        "D": "0",
        "Answer": "B",
        "Explanation": "The expected output may be 10 because the value of member of object x is printed. But when object x is assigned to y, y points to the same address where x is stored. So actually both objects x and y point to the same location and refers to the same object.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "If programmer doesn’t define any copy assignment operator then ____________________  ",
        "A": "Compiler gives an error",
        "B": "Program fails at run time",
        "C": "Compiler gives an implicit definition",
        "D": "Compiler can’t copy the member values",
        "Answer": "C",
        "Explanation": "While defining a copy constructor, we use reference const parameter, those are used for the assignment. The assignment operator may or may not be defined by the programmer, if not, compiler implicitly defines member wise copy assignment operator.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "In copy constructor definition, if non const values are accepted only ____",
        "A": " Only const objects will be accepted",
        "B": "Only non – const objects are accepted",
        "C": "Only const members will not get copied",
        "D": "Compiler generates an error",
        "Answer": "B",
        "Explanation": "Only the non – const objects will be accepted by the compiler. If a const object is passed, the compiler produces an error. To reduce that, we use const argument in definition, so that both const and non – const objects are accepted.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": " How many objects can be assigned to a single address?      ",
        "A": " Only 1",
        "B": "At most 7",
        "C": "At most 3",
        "D": "As many as required",
        "Answer": "D",
        "Explanation": "The memory address can be referenced by more than one object. There is no maximum number defined. Any number of objects can reference to the same address.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "Use of assignment operator ____________________             ",
        "A": "Changes its use, when used at declaration and in normal assignment",
        "B": "Doesn’t changes its use, whatever the syntax might be",
        "C": "Assignment takes place in declaration and assignment syntax",
        "D": "Doesn’t work in normal syntax, but only with declaration",
        "Answer": "A",
        "Explanation": "The assignment operator if used at declaration then it uses copy constructor for the copying of objects. If used in simple assignment syntax then it uses copy assignment function.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "If more than one object refer to the same address, any changes made ",
        "A": "Can be made visible to specific objects",
        "B": "Will be specific to one object only",
        "C": "From any object will be visible in all",
        "D": "Doesn’t changes the values of all objects",
        "Answer": "C",
        "Explanation": " At a memory address, only one object can be referenced. All the other objects which refer to the same memory address make changes for all of the objects referring that address.advertisement",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "How to make more than one object refer to the same object?     ",
        "A": "Initialize it to null",
        "B": "Initialize the object with another at declaration",
        "C": "Use constructor to create new object",
        "D": "Assign the address directly",
        "Answer": "B",
        "Explanation": "The object must get initialized with another object at time of declaration only. We don’t have to create a new object we just have to get name of new object because there after same address will be referred.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "We can assign ______________________    ",
        "A": "Value of one reference variable to another",
        "B": "Value of any object to another",
        "C": "Value of any type to any object",
        "D": "Value of non – reference to another reference",
        "Answer": "A",
        "Explanation": "Only the reference value can be assigned to another reference value. This is because both deal with the address. There is no type mismatch hence we can assign them.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "Assigning reference to an object _____",
        "A": "Will create another copy of the object",
        "B": "Will create two different copies of the object",
        "C": "Will not create any other copy of the object",
        "D": "Will not refer to the object",
        "Answer": "C",
        "Explanation": " When an object is assigned with another object. Same memory location is used. There is no other copy of the object created.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "Which among the following is true?     ",
        "A": "We can use direct assignment for any object",
        "B": " We can use direct assignment only for different class objects",
        "C": "We must not use direct assignment",
        "D": "We can use direct assignment to same class objects",
        "Answer": "D",
        "Explanation": "The direct assignment can be used with the same class objects. There is no restriction on them. But better if the program have a predefined copy assignment operator.",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "Which language among the following doesn’t allow pointers?   ",
        "A": "C++",
        "B": "Java",
        "C": "Pascal",
        "D": "C",
        "Answer": "B",
        "Explanation": "The concept of pointers is not supported in Java. The feature is not given in the language but can be used in some ways explicitly. Though this pointer is supported by java too.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "Which is correct syntax for declaring pointer to object?    ",
        "A": "className* objectName;",
        "B": "className objectName;",
        "C": " *className objectName;",
        "D": "className objectName();",
        "Answer": "A",
        "Explanation": "The syntax must contain * symbol after the className as the type of object. This declares an object pointer. This can store address of any object of the specified class.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "Which operator should be used to access the members of the class using object pointer?",
        "A": "Dot operator",
        "B": "Colon to the member",
        "C": "Scope resolution operator",
        "D": "Arrow operator",
        "Answer": "D",
        "Explanation": "The members can be accessed from the object pointer by using arrow operator. The arrow operator can be used only with the pointer of class type. If simple object is declared, it must use dot operator to access the members.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "How does compiler decide the intended object to be used, if more than one object are used?   ",
        "A": "Using object name",
        "B": "Using an integer pointer",
        "C": "Using this pointer",
        "D": "Using void pointer",
        "Answer": "C",
        "Explanation": "This pointer denotes the object, in which it is being used. If member function is called with respect to one object then this pointer refers to the same object members. It can be used when members with same name are involved.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "If pointer to an object is declared, _________",
        "A": "It can store any type of address",
        "B": "It can store only void addresses",
        "C": "It can only store address of integer type",
        "D": "It can only store object address of class type specified",
        "Answer": "D",
        "Explanation": " The address of only the specified class type can get their address stored in the object pointer. The addresses doesn’t differ but they do differ for the amount and type of memory required for objects of different classes. Hence same class object pointer should be used.",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "What is the size of object pointer?          ",
        "A": "Equal to size of any usual pointer",
        "B": "Equal to size of sum of all the members of object",
        "C": "Equal to size of maximum sized member of object",
        "D": "Equal to size of void",
        "Answer": "A",
        "Explanation": "The size of object pointer is same as that of any usual pointer. This is because only the address have to be stored. There are no values to be stored in the pointer.",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "A pointer _________________       ",
        "A": "Can point to only one object at a time",
        "B": "Can point to more than one objects at a time",
        "C": "Can point to only 2 objects at a time",
        "D": "Can point to whole class objects at a time",
        "Answer": "A",
        "Explanation": "The object pointer can point to only one object at a time. The pointer will be able to store only one address at a time. Hence only one object can be referred.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "Pointer to a base class can be initialized with the address of derived class, because of _________     ",
        "A": "derived-to-base implicit conversion for pointers",
        "B": "Yes, only if it is only pointer to object",
        "C": "No, because objects can be referenced from another objects too",
        "D": "No, never",
        "Answer": "D",
        "Explanation": " It is an implicit rule defined in most of the programming languages. It permits the programmer to declare a pointer to the derived class from a base class pointer. In this way the programmer doesn’t have to declare object for derived class each time it is required.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "Can pointers to object access the private members of the class?   ",
        "A": "Yes, always",
        "B": "Yes, only if it is only pointer to object",
        "C": "No, because objects can be referenced from another objects too",
        "D": "No, never",
        "Answer": "D",
        "Explanation": "The pointers to an object can never access the private members of the class outside the class. The object can indirectly use those private members using member functions which are public in the class.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "Is name of an array of objects is also a pointer to object?      ",
        "A": "Yes, always",
        "B": "Yes, in few cases",
        "C": "No, because it represents more than one object",
        "D": "No, never",
        "Answer": "A",
        "Explanation": "The array name represents a pointer to the object. The name alone can represent the starting address of the array. But that also represents an array which is in turn stored in a pointer.",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "Which among the following is true?     ",
        "A": "The pointer to object can hold address only",
        "B": "The pointer can hold value of any type",
        "C": "The pointer can hold only void reference",
        "D": "The pointer can’t hold any value",
        "Answer": "A",
        "Explanation": "The pointer to an object can hold only the addresses. Address of any other object of same class. This allows the programmer to link more than one objects if required.",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "Which is the correct syntax to call a member function using pointer?        ",
        "A": "pointer->function()  ",
        "B": "pointer.function()",
        "C": "pointer::function()",
        "D": "pointer:function()",
        "Answer": "A",
        "Explanation": "The pointer should be mentioned followed by the arrow operator. Arrow operator is applicable only with the pointers. Then the function name should be mentioned that is to be called. advertisement",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "If pointer to an object is created and the object gets deleted without using the pointer",
        "A": "It becomes void pointer",
        "B": "It becomes dangling pointer",
        "C": "t becomes null pointer",
        "D": "It becomes zero pointer",
        "Answer": "B",
        "Explanation": "When the address pointed by the object pointer gets deleted, the pointer now points to an invalid address. Hence it becomes a dangling pointer. It can’t be null or void pointer since it doesn’t point to any specific location.",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "How can the address stored in the pointer be retrieved?  ",
        "A": "Using * symbol",
        "B": "Using $ symbol",
        "C": "Using & symbol",
        "D": "Using @ symbol",
        "Answer": "C",
        "Explanation": "The & symbol must be used. This should be done such that the object should be preceded by & symbol and then the address should be stored in another variable. This is done to get the address where the object is stored.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "What should be done to prevent changes that may be made to the values pointed by the pointer?    ",
        "A": "Usual pointer can’t change the values pointed",
        "B": "Pointer should be made virtual",
        "C": "Pointer should be made anonymous",
        "D": "Pointer should be made const",
        "Answer": "D",
        "Explanation": "The pointer should be declared as a const type. This prevents the pointer to change any value that is being pointed from it. This is a feature that is made to access the values using pointer but to make sure that pointer doesn’t change those values accidently.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "Which is the pointer which denotes the object calling the member function?",
        "A": "Variable pointer",
        "B": "This pointer",
        "C": "Null pointer",
        "D": "Zero pointer",
        "Answer": "B",
        "Explanation": "The pointer which denotes the object calling the member function is known as this pointer. The this pointer is usually used when there are members in the function with same name as those of the class members.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": " Which among the following is true?          ",
        "A": "this pointer is passed implicitly when member functions are called",
        "B": "this pointer is passed explicitly when member functions are called",
        "C": "this pointer is passed with help of pointer member functions are called",
        "D": "this pointer is passed with help of void pointer member functions are called",
        "Answer": "A",
        "Explanation": " When an object calls some member function, it implicitly passes itself as an argument. This allows the compiler to know which member should be used for the purposes. This also allows to reduce the ambiguity among the variable and data member names.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "The this pointer is accessible __________________           ",
        "A": "Within all the member functions of the class",
        "B": "Only within functions returning void",
        "C": "Only within non-static functions",
        "D": "Within the member functions with zero arguments",
        "Answer": "C",
        "Explanation": "The this pointer is available only within the non-static member functions of a class. If the member function is static, it will be common to all the objects and hence a single object can’t refer to those functions independently.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "An object’s this pointer ___________",
        "A": "Isn’t part of class",
        "B": " Isn’t part of program",
        "C": "Isn’t part of compiler",
        "D": "Isn’t part of object itself",
        "Answer": "D",
        "Explanation": "The object’s this pointer being called are not part of the object itself. This can be cross verified by checking that it doesn’t take up any space for the data to be stored or pointed.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "The result of sizeof() function __________________     ",
        "A": " Includes space reserved for this pointer",
        "B": "Includes space taken up by the address pointer by this pointer",
        "C": "Doesn’t include the space taken by this pointer",
        "D": "Doesn’t include space for any data member",
        "Answer": "C",
        "Explanation": "The space taken by this pointer is not reflected in by the sizeof() operator. This is because object’s this pointer is not part of object itself. This is a cross verification for the concept stating that this pointer doesn’t take any space in the object.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "Whenever non-static member functions are called ___________",
        "A": "Address of the object is passed implicitly as an argument",
        "B": "Address of the object is passed explicitly as an argument",
        "C": "Address is specified globally so that the address is not used again",
        "D": "Address is specified as return type of the function",
        "Answer": "D",
        "Explanation": "The address is passed implicitly as an argument to the function. This doesn’t have to be passed explicitly. The address is passed, of the object which is calling the non-static member function.",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "Which is the correct interpretation of the member function call from an object, object.function(parameter);   ",
        "A": "object.function(&this, parameter)",
        "B": "object(&function,parameter)",
        "C": "function(&object,&parameter)",
        "D": "function(&object,parameter)",
        "Answer": "D",
        "Explanation": "The function name is specified first and then the parameter lists. The parameter list is included with the object name along with & symbol. This denotes that the address of the object is being passed as an argument.",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "The address of the object __________",
        "A": " Can’t be accessed from inside the function",
        "B": "Can’t be accessed in the program",
        "C": " Is available inside the member function using this pointer",
        "D": "Can be accessed using the object name inside the member function",
        "Answer": "C",
        "Explanation": "The address of the object with respect to which the member functions are being called, are stored in this pointer. This pointer is hence used whenever there are members with same name as those of the variables inside the function.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "Which among the following is true?       ",
        "A": "This pointer can be used to guard against any kind of reference",
        "B": "This pointer can be used to guard against self-reference",
        "C": "This pointer can be used to guard from other pointers",
        "D": "This pointer can be used to guard from parameter referencing",
        "Answer": "B",
        "Explanation": "The this pointer can be used to guard itself whenever self-reference is used. This allows accidental address access. And accidental modification of data.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "Which syntax doesn’t execute/is false when executed?       ",
        "A": "if(&object != this)",
        "B": "if(&function !=object)",
        "C": "this.if(!this)",
        "D": "this.function(!this)",
        "Answer": "A",
        "Explanation": "The condition becomes false when executed and hence doesn’t executes. This is the case where this pointer can guard itself from the self-reference. Here if the address of the object doesn’t match with this pointer that means the object doesn’t refer itself.",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "The this pointers _____________________  ",
        "A": "Are modifiable",
        "B": " Can be assigned any value",
        "C": "Are made variables",
        "D": "Are non-modifiable",
        "Answer": "D",
        "Explanation": " The this pointer is non modifiable. This is because the address of any object remains constant throughout its life time. Hence the address must not be changed otherwise wrong members of invalid addresses might get accessed.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "Earlier implementations of C++ _______________",
        "A": "Never allowed assignment to this pointer",
        "B": " Allowed no assignment to this pointer",
        "C": "Allowed assignments to this pointer",
        "D": " Never allowed assignment to any pointer",
        "Answer": "C",
        "Explanation": "The earlier, most initial versions of C++ used to allow assignments to this pointers. That used to allow modifications of this pointer. Later that feature got disabled.advertisement",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "This pointer can be used directly to ___________ ",
        "A": "To manipulate self-referential data structures",
        "B": "To manipulate any reference to pointers to member functions",
        "C": "To manipulate class references",
        "D": "To manipulate and disable any use of pointers",
        "Answer": "A",
        "Explanation": "This is a feature provided, that can be used directly. The manipulation of self-referential data structures is just an application of this feature. Other conditions fails as this pointer doesn’t deal with those things.",
        "Difficulty": "1",
        "StID": "8"
    },
    {
        "Questions": "Which among the following is/are type(s) of this pointer?  ",
        "A": " const",
        "B": "volatile",
        "C": "const or volatile",
        "D": "int",
        "Answer": "C",
        "Explanation": "The this pointer can be declared const or volatile. This depends on need of program and type of code. This is just an additional feature.",
        "Difficulty": "2",
        "StID": "8"
    },
    {
        "Questions": "Which is the correct syntax for declaring type of this in a member function?   ",
        "A": "classType [cv-qualifier-list] *const this;",
        "B": "classType const[cv-qualifier-list] *this;",
        "C": "[cv-qualifier-list]*const classType this;",
        "D": "[cv-qualifier-list] classType *const this;",
        "Answer": "D",
        "Explanation": "The syntax contains the cv-qualifier-list that can be determined from the member function declaratory that can be either const or volatile or can be made both. Hence we write it as list. classType denotes the name of class to mention to which class does the object belong to. And *const this denotes that the this pointer is having a constant value.",
        "Difficulty": "3",
        "StID": "8"
    },
    {
        "Questions": "What are default arguments?      ",
        "A": "Arguments which are not mandatory to be passed",
        "B": "Arguments with default value that aren’t mandatory to be passed",
        "C": "Arguments which are not passed to functions",
        "D": "Arguments which always take same data value",
        "Answer": "B",
        "Explanation": "The arguments which are assigned with some default value. Since some value is already given, it is not mandatory to pass those arguments. They can be used directly.",
        "Difficulty": "3",
        "StID": "9"
    },
    {
        "Questions": "Which is correct condition for the default arguments?   ",
        "A": "Those must be declared as last arguments in argument list",
        "B": "Those must be declared first in the argument list",
        "C": "Those can be defined anywhere in the argument list",
        "D": "Those are declared inside the function definition",
        "Answer": "A",
        "Explanation": "The default arguments must be declared at last in the argument list. This is to ensure that the arguments doesn’t create ambiguity. The normal arguments should be passed first.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "If a member function have to be made both zero argument and parameterized constructor, which among the following can be the best option? ",
        "A": "Two normal and one default argument",
        "B": "At least one default argument",
        "C": "Exactly one default argument",
        "D": "Make all the arguments default",
        "Answer": "D",
        "Explanation": "All the arguments must be made default. This will make sure that none of the arguments are mandatory to be passed. Which in turn means that the function can work without any argument and can be passed with arguments too.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "Which among the following function can be called without arguments?   ",
        "A": "void add(int x, int y=0)",
        "B": "void add(int=0)",
        "C": "void add(int x=0, int y=0)",
        "D": "void add(char c)",
        "Answer": "C",
        "Explanation": "For the function to be called without arguments, either it must have zero arguments or it must have all the default arguments. Here the function in option c have all the default arguments and hence can be called directly with zero argument.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": "If a function have all the default arguments but still some values are passed to the function then ____",
        "A": "The function will use the values passed to it",
        "B": "The function will use the default values as those are local",
        "C": "The function can use any value whichever is higher",
        "D": " The function will choose the minimum values",
        "Answer": "A",
        "Explanation": "The function will use the values passed explicitly to it. The default values will be ignored. The default values are used only in case the values are not passed explicitly to the function.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": "Which among the following is correct?   ",
        "A": "void test(int x=0, int y, int z=0)",
        "B": "void test(int x=0,int=0)",
        "C": "void test(int x,int y=0)",
        "D": "void test(int x=’c’,int y)",
        "Answer": "C",
        "Explanation": "The default arguments must be mentioned at last in the argument list. Also the type of values assigned must match with the argument type. All the default arguments must be mentioned at last, none of the normal arguments should come in between the default arguments list.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": " What function will be called with the independent syntax “test(5,6,7);”?",
        "A": " void test(int x, int y)",
        "B": "void test(int x=0,int y,int z)",
        "C": "int test(int x=0,y=0,z=0)",
        "D": "void test(int x,int y, int z=0)",
        "Answer": "D",
        "Explanation": "There are three arguments that are getting passed to the function test(). Only the last option have all the default argument at last in the argument list. And the total number of the arguments is three. The third option is wrong because the return type is int and the syntax given is independent which means it doesn’t return any value.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": "Which among the following is wrong call to the function void test(int x, int y=0, int z=0)?",
        "A": "test(5,6,7);",
        "B": " test(5);",
        "C": "test();",
        "D": "test(5,6);",
        "Answer": "C",
        "Explanation": "The function must be passed with at least one argument. There is two default arguments and one normal argument which must be passed with some value. Hence third call to the function is wrong as it doesn’t pass even a single parameter to the function",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": "Default arguments are ____",
        "A": "Only allowed in the parameter list of the function declaration",
        "B": "Only allowed in the return type of the function declaration",
        "C": "Only allowed with the class name definition",
        "D": "Only allowed with the integer type values",
        "Answer": "A",
        "Explanation": "The default arguments are only allowed in the parameter list of the function arguments. This rule was not applicable in the beginning versions of c++ but later from c++ 14th version it has been implemented. This is the only way to use default arguments.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": "Which among the following is false for default arguments?",
        "A": "Those are not allowed with declaration of pointer to functions",
        "B": "Those are not allowed with the reference to functions",
        "C": "Those are not allowed with the typedef declarations",
        "D": "Those are allowed with pointer and reference to function declaration",
        "Answer": "D",
        "Explanation": "The statements given are true because that is a feature given to make the programming more flexible and have some security with accidental changes at same time. The last option is false because it is not a rule defined. It is an opposite statement to the rules defined for default arguments.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "The non-template functions can be added with default arguments to already declared functions ___________________",
        "A": "If and only if the function is declared again in the same scope",
        "B": "If and only if the function is declared only once in the same scope",
        "C": "If and only if the function is declared in different scope",
        "D": "If and only if the function is declared twice in the program",
        "Answer": "A",
        "Explanation": "The non-template functions can also be added with default arguments. This can be done even if the functions were defined earlier. This is because the call to the function won’t be affected. The function can still be used in the same way as it was used earlier.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": "The using declaration __________  ",
        "A": "Doesn’t carry over the default values",
        "B": "Carries over the known default arguments",
        "C": "Carries over only the normal arguments",
        "D": "Carries over only few default arguments",
        "Answer": "B",
        "Explanation": "The using-declaration carries over all the known default arguments. This is a common feature as the usage doesn’t gets affected even if the default arguments are added. This comes under flexible programming.\r\nadvertisement",
        "Difficulty": "3",
        "StID": "9"
    },
    {
        "Questions": "The names given to the default arguments are only looked up and ________________. And are bound during declaration.   ",
        "A": "Checked for availability",
        "B": " Checked for random access",
        "C": " Checked for accessibility",
        "D": "Checked for feasibility",
        "Answer": "C",
        "Explanation": "The names given to the default arguments are bound at time of declaration but are only checked for accessibility and to get bounded. This is mainly to bind those members during declaration.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": "The default argument get bound during declaration __",
        "A": "And are never executed",
        "B": "And are executed simultaneously",
        "C": "But are executed only if priority is given",
        "D": "But are executed during function call",
        "Answer": "D",
        "Explanation": "The default argument are bound at time of declaration. That is an implicit functioning. But those are executed only when the function is called. Otherwise those will never get executed.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "The virtual function overrides ____________    ",
        "A": "Do not acquire base class declaration of default arguments",
        "B": "Do acquire base class declaration of default arguments",
        "C": "Do not link with the default arguments of base class",
        "D": "Do link with the default argument but only of derived classes",
        "Answer": "A",
        "Explanation": "The virtual function overrides do not acquire the base class declaration of default arguments. Even if a call to the virtual function is made, static type of the object decides the default arguments to be used\r\n",
        "Difficulty": "3",
        "StID": "9"
    },
    {
        "Questions": "Which among the following is true for constructors overloading?  ",
        "A": "Constructors can’t be overloaded",
        "B": "Constructors can be overloaded using different signatures",
        "C": "Constructors can be overloaded with same signatures",
        "D": "Constructors can be overloaded with different return types",
        "Answer": "B",
        "Explanation": "The constructors can be overloaded only if the definitions have different signatures. Constructors doesn’t have any return type so can’t be overloaded using return type. If constructors have same signature then it will produce a compile time error",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "If a constructors should be capable of creating objects without argument and with arguments, which is a good alternative for this purpose?     ",
        "A": "Use zero argument constructor",
        "B": "Use constructor with one parameter",
        "C": "Use constructor with all default arguments",
        "D": "Use default constructor",
        "Answer": "C",
        "Explanation": "The constructor should use all the default arguments. This will allow the constructor to be called even if no arguments are passed. And if arguments are passed, those will be accepted instead of the default values.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": " Which among the following is true?      ",
        "A": "The constructors overloading can be done by using different names",
        "B": "The constructors overloading can be done by using different return types",
        "C": "The constructors can be overloaded by using only one argument",
        "D": "The constructors must have same name as that of class",
        "Answer": "D",
        "Explanation": "The constructors must have same name as that of the class name. This is mandatory because only the constructor functions doesn’t have any return type. Also, for overloading all the functions must have the same name.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "Which among the following can be used in place of default constructor?",
        "A": " constructorName(int x,int y=0)",
        "B": " constructorName(int x=0,int y=0)",
        "C": "constructorName(int x=0,int y)",
        "D": "constructorName(int x,int y)",
        "Answer": "B",
        "Explanation": " For a parameterized constructor to be used as a default constructor, it must have all the default arguments. This makes the constructor to have optional arguments which are not mandatory to be passed.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": "Can a class have more than one function with all the default arguments?",
        "A": "Yes, always",
        "B": "Yes, if argument list is different",
        "C": " No, because constructors overloading doesn’t depend on argument list",
        "D": "No, never",
        "Answer": "D",
        "Explanation": "A single class can never have more than once constructor with all the default arguments. This is because it will make all those constructors as a default constructor. And when an object is created with zero arguments then it will create ambiguity.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "Which is the correct syntax for using default arguments with the constructor?",
        "A": " default constructorName(default int x=0)",
        "B": "constructorName(default int x=0)",
        "C": "constructorName(int x=0)",
        "D": "constructorName()",
        "Answer": "C",
        "Explanation": " The constructors using the default arguments must initialize the arguments in the argument list. This is to make the constructor use the default value when no arguments are passed. If no arguments are listed then it is a default constructor.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": "How many parameters must be passed if only the following prototype is given to a constructor?        Prototype: className(int x, int y, int z=0);",
        "A": "1",
        "B": "2",
        "C": "3",
        "D": "Compile time err",
        "Answer": "B",
        "Explanation": "In the prototype given, only 2 arguments are mandatory. Since the third argument is default argument, so it is not mandatory to pass the argument.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": " If the constructors are overloaded by using the default arguments, which problem may arise?      ",
        "A": "The constructors might have all the same arguments except the default arguments",
        "B": "The constructors might have same return type",
        "C": "The constructors might have same number of arguments",
        "D": "The constructors can’t be overloaded with respect to default arguments",
        "Answer": "A",
        "Explanation": "The constructors having same arguments except the default arguments can give rise to errors. If only the mandatory arguments are passed, it will create ambiguity in calling the correct constructor. Hence the mandatory arguments must be different.",
        "Difficulty": "3",
        "StID": "9"
    },
    {
        "Questions": "Which among the following is true? ",
        "A": "More than one constructors with all default arguments is allowed",
        "B": "More than one constructors with all default arguments can be defined outside the class",
        "C": "More than one constructors can be used with same argument list",
        "D": "More than one constructors with all default arguments can’t exist in same class",
        "Answer": "D",
        "Explanation": "The constructors must have different argument list. Along that, if all the arguments are default arguments, there can’t be more than once constructor like that in the same class as that will create ambiguity while constructors are being called.",
        "Difficulty": "3",
        "StID": "9"
    },
    {
        "Questions": " Which constructor among the following will be called if a call is made like className(5,’a’);?         ",
        "A": " className(int x=5,char c=’a’);",
        "B": "int className(int x, char c, char d);",
        "C": "className(int x, char c, int y);",
        "D": "char className(char c,int x);",
        "Answer": "A",
        "Explanation": "The syntax given is passing two parameters to the constructor call. One value is of integer type and another of character type. Hence the constructor with arguments of int and char type should be called. There is only one option which first accepts integer value and then a character value. Hence that constructor will be called.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": "Which constructor definition will produce a compile time error? ",
        "A": "className(int x=0);",
        "B": "className(char c);",
        "C": "className(int x=0,char c);",
        "D": "className(char c,int x=0);",
        "Answer": "C",
        "Explanation": "The default arguments, just like with member functions, must be listed at last in the argument list. Hence this will produce a compile time error. The compiler doesn’t allow the definition to be executed. advertisement",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": " If there is a constructor with all the default arguments and arguments are not passed then _________________             ",
        "A": "The default values given will not be used",
        "B": "Then all the null values will be used",
        "C": " Then all the default values given will be used",
        "D": "Then compiler will produce an error",
        "Answer": "C",
        "Explanation": "The constructors will use the default values listed for use. The null values are not used because those are not specified. Though if it was compiler provided default constructor, then it would have initialized the members to null or zero values.",
        "Difficulty": "3",
        "StID": "9"
    },
    {
        "Questions": "Which is the correct statement for default constructors?  ",
        "A": "The constructors with all the default arguments",
        "B": "The constructors with all the null and zero values",
        "C": "The constructors which can’t be defined by programmer",
        "D": "The constructors with zero arguments",
        "Answer": "D",
        "Explanation": "The closest answer to the question is that a default constructor is a constructor with zero arguments. But this is not the actual case. Actually the constructors provided by the compiler are default constructors. And the constructors with zero arguments defined by the programmer are zero argument constructors.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": "Which is a good alternative instead of having one zero argument constructor and one single argument constructor with default argument?        ",
        "A": "No constructor defined",
        "B": "One default value constructor",
        "C": "Defining the default constructor",
        "D": " Using one constructor with two arguments",
        "Answer": "B",
        "Explanation": "The constructor with one default argument can be the best alternative. This is because the constructor with one default value will do the work for both the default constructor and one argument constructor",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "What is upcasting?  ",
        "A": "Casting subtype to supertype",
        "B": "Casting super type to subtype",
        "C": "Casting subtype to super type and vice versa",
        "D": "Casting anytype to any other type",
        "Answer": "A",
        "Explanation": "The upcasting concept includes only the casting of subtypes to the super types. This casting is generally done implicitly. Smaller size types can fit into larger size types implicitly.",
        "Difficulty": "3",
        "StID": "9"
    },
    {
        "Questions": "Which among the following is true for upcasting in inheritance?    ",
        "A": "Downward to the inheritance tree",
        "B": " Upward to the inheritance tree",
        "C": "Either upward or downward",
        "D": " Doesn’t apply on inheritance",
        "Answer": "B",
        "Explanation": "The upcasting concept in inheritance is always applied upward the inheritance tree. The derived class objects can be type casted to any of its parent class type. Since is a relationship applies in general inheritance.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "Which among the following is safe?     ",
        "A": "Upcasting",
        "B": "Downcasting",
        "C": "Both upcasting and downcasting",
        "D": "If upcasting is safe then downcasting is not, and vice versa",
        "Answer": "A",
        "Explanation": "The upcasting is always safe since the derived type or the smaller type is converted into the base type or the larger size. This results in allocating a smaller size data into bigger type data. No data is lost in casting, hence safe.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "Which among the following is best situation to use upcasting? ",
        "A": "For general code dealing with only subtype",
        "B": " For general code dealing with only supertype",
        "C": "For general code dealing with both the supertype and subtype",
        "D": "For writing a rigid code with respect to subtype",
        "Answer": "B",
        "Explanation": "When a general code has to be written where we use only the supertype object or the data of bigger size, then upcasting would be the best option. Since the whole code will require only the supertype name references.",
        "Difficulty": "3",
        "StID": "9"
    },
    {
        "Questions": "Which property is shown most when upcasting is used?   ",
        "A": "Code reusability",
        "B": "Code efficiency",
        "C": "Complex code simple syntax",
        "D": "Encapsulation",
        "Answer": "C",
        "Explanation": "The code written using upcasting mostly shows complex code in simpler syntax feature. This is because the upcasting concept can be applied as polymorphism and to group the similar type of objects.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "Which casting among the following is allowed for the code given below? class A\r\n{\r\n public :int a;\r\n}\r\nclass B:public A\r\n{\r\n int b;\r\n}\r\nmain()\r\n{\r\n B b=new A();  //casting 1\r\n A a=new B();  //casting 2\r\n}",
        "A": "Casting 1",
        "B": "Casting 2",
        "C": " casting 1 and casting 2",
        "D": "casting 1 nor casting 2",
        "Answer": "B",
        "Explanation": "The casting 2 is correct. The objects casting must be done from derived class object to a parent class object. That is, the object of the superclass can be made an object of subclass only. Vice versa is not possible.",
        "Difficulty": "3",
        "StID": "9"
    },
    {
        "Questions": "If multiple inheritance is implemented, which upcasting will be correct?",
        "A": "Upcast to first base class listed in inheritance",
        "B": " Upcast to send base class listed in inheritance",
        "C": "Upcast to any base class",
        "D": "Upcast is not possible",
        "Answer": "C",
        "Explanation": "The upcasting of derived class object is possible to any base class. This is because the base class object can represent any of its derived classes using upcasting.",
        "Difficulty": "3",
        "StID": "9"
    },
    {
        "Questions": "If class C inherits class B and class B inherits class A ___________",
        "A": "Class C object can be upcasted to object of class B only",
        "B": "Class C object can be upcasted to object of class A only",
        "C": "Class C object can be upcasted to object of either class A or B",
        "D": "Class C object can’t be upcasted",
        "Answer": "C",
        "Explanation": "Both class A and B are parent classes of class C. Class C object hence can be upcasted to any of those class objects. It is not compulsory to upcast to nearest parent.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "Upcasting is _____________________ without an explicit type cast.",
        "A": "Always allowed for public inheritance",
        "B": " Always allowed for protected inheritance",
        "C": "Always allowed for private inheritance",
        "D": "Not allowed",
        "Answer": "A",
        "Explanation": "The public inheritance shows the most flexible is-a relationship. Hence explicit type casting is not required. Implicit type casting is done by the compiler.advertisement.advertisement",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": " Which concept is needed because of implicit type casting use?      ",
        "A": "Static binding",
        "B": "Dynamic binding",
        "C": "Compile time binding",
        "D": "Source code binding",
        "Answer": "B",
        "Explanation": "Since the implicit type casting allows casting of a base class pointer to refer to its derived class object or even base class object. We need dynamic type casting so that the references can be resolved during execution of program.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": " When are the pointer types known for upcasting the objects?",
        "A": "Compile time",
        "B": "Runtime",
        "C": "Source code build time",
        "D": "Doesn’t apply to pointer types",
        "Answer": "A",
        "Explanation": "The pointer or reference types are known at compile time for the upcasting of an object. This is because the addresses must be known for casting the derived class to base class object.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": "When are the object type known for upcasting the objects?      ",
        "A": "Compile time",
        "B": "Runtime",
        "C": "Source code build time",
        "D": "Doesn’t apply to objects directly",
        "Answer": "B",
        "Explanation": "The upcasting with objects directly requires runtime resolving. The objects are fixed and address are allocated at compile time. But the execution of a program requires runtime knowledge of object types, for implicit type cast.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": " If two classes are defined “Parent” and “Child” then which is the correct type upcast syntax in C++?       ",
        "A": "Parent *p=child;",
        "B": " Parent *p=*child;",
        "C": "Parent *p=&child;",
        "D": "Parent *p=Child();",
        "Answer": "C",
        "Explanation": "The syntax must contain the base class name first. So that the parent class object pointer can be declared. Then the object is assigned with the derived class object with & symbol. & symbol is added to get the address of derived class object.",
        "Difficulty": "3",
        "StID": "9"
    },
    {
        "Questions": "Which among the following is true?      ",
        "A": "Upcasting is possible only for single level inheritance",
        "B": "Upcasting is possible only for multilevel inheritance",
        "C": "Upcasting is possible only for multiple inheritance",
        "D": " Upcasting is possible for any type of inheritance",
        "Answer": "D",
        "Explanation": "The type of inheritance doesn’t matter with the upcasting concept. Upcasting applies to all types of inheritance. Any derived class object can be upcasted to any of its base class object",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": "What is downcasting?     ",
        "A": "It must not be done explicitly",
        "B": " It must be done implicitly",
        "C": " It must be done explicitly",
        "D": "It can’t be done explicitly",
        "Answer": "C",
        "Explanation": "The downcasting of any object must be done explicitly. This is because the compilers don’t support the implicit conversion of a supertype to subtype.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "Which among the following is a mandatory condition for downcasting?   ",
        "A": "It must not be done explicitly",
        "B": "It must be done implicitly",
        "C": " It must be done explicitly",
        "D": "It can’t be done explicitly",
        "Answer": "C",
        "Explanation": "The downcasting of any object must be done explicitly. This is because the compilers don’t support the implicit conversion of a supertype to subtype.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": " Downcasting is ____________",
        "A": "Always safe",
        "B": " Never safe",
        "C": "Safe sometimes",
        "D": "Safe, depending on code",
        "Answer": "B",
        "Explanation": "The downcasting concept is made for exception cases. When there is a need to represent an entity in the form which is not suitable for it. Representing a base type in derived type is not right but can be done for special cases.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": "Downcasting _______________",
        "A": " Can result in unexpected results   ",
        "B": " Can’t result in unexpected result",
        "C": "Can result only in out of memory error",
        "D": "Can’t result in any error",
        "Answer": "A",
        "Explanation": "The result of downcasting can be unexpected. This is because downcasting is done on the objects into the objects which doesn’t contain any information of data in lateral object.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": "What should be used for safe downcast?",
        "A": "Static cast",
        "B": "Dynamic cast",
        "C": "Manual cast",
        "D": "Implicit cast",
        "Answer": "B",
        "Explanation": "The dynamic cast can be done using the operator dynamic_cast. This converts one type to another type in safe way.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "What does dynamic_cast return after successful type casting?       ",
        "A": "Address of object which is converted",
        "B": "Address of object that is used for conversion",
        "C": "Address of object that is mentioned in the syntax",
        "D": "Doesn’t return any address",
        "Answer": "A",
        "Explanation": "The address of the object which is converted is returned by the dynamic_cast operator. This is done to safely convert the subtype to supertype. This ensures the proper assignment and conversion from one type to another.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "If dynamic_cast fails, which value is returned?     ",
        "A": " void",
        "B": "null",
        "C": "void pointer",
        "D": "null pointer",
        "Answer": "D",
        "Explanation": "The null pointer is returned by the dynamic_cast, if it fails. The conversion sometimes fails because of too complex type conversion. The conversion may also fail due to memory or some related issues.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": "Which is the proper syntax of dynamic_cast?       ",
        "A": "dynamic_cast(object)",
        "B": "dynamic_cast new (object)",
        "C": "dynamic_cast(object)",
        "D": "dynamic_cast(object)",
        "Answer": "A",
        "Explanation": "The dynamic_cast is the name of operator, which is followed by the new type in which the object have to be converted. Then the object name is given. This object name is then used after the type conversion.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "Which is the exception handler for the exceptions of downcasting?   ",
        "A": "CastException",
        "B": "ClassCastingExeption",
        "C": "ClassCasting",
        "D": "ClassCastException",
        "Answer": "D",
        "Explanation": "The exception handler for the exceptions produced during the downcasting exception. This handler can be called during runtime to handle any exception thrown.",
        "Difficulty": "3",
        "StID": "9"
    },
    {
        "Questions": "How to prevent the ClassCastExceptions?        ",
        "A": " By using instanceof",
        "B": " By using is-a check",
        "C": "By using arrow operator with check function",
        "D": "By checking type of conversion",
        "Answer": "A",
        "Explanation": "The instanceof operator can be used to check the compatibility of the conversion. This has to be done to check whether the casting would be safe or not.",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": " Which way the downcasting is possible with respect to inheritance? ",
        "A": "Upward the inheritance order",
        "B": "Downward the inheritance order",
        "C": "Either upward or downward the inheritance order",
        "D": "Order of inheritance doesn’t matter",
        "Answer": "B",
        "Explanation": "The downcasting is always downward the inheritance order. Since the base class object have to be casted into derived class type. This is basic definition of downcasting.advertisement",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "What happens when downcasting is done but not explicitly defined in syntax",
        "A": "Compile time error",
        "B": " Runtime error",
        "C": "Code write time error",
        "D": "Conversion error",
        "Answer": "A",
        "Explanation": "The implicit downcasting is not possible. If tried, the compiler produces an error. Since the compiler doesn’t allow coasting to a type which is not compatible.",
        "Difficulty": "3",
        "StID": "9"
    },
    {
        "Questions": "When is downcating used?     ",
        "A": "To separate inherited class from base class",
        "B": "To write a more complex code",
        "C": "To compare two objects",
        "D": " To disable one class in inheritance",
        "Answer": "C",
        "Explanation": "The downcasting can be used whenever there is a need to compare one object to another. Equals() function can be used to compare whether the objects were of same age. We can use getClass() function too.",
        "Difficulty": "1",
        "StID": "9"
    },
    {
        "Questions": "Why is downcasting possible in any language?",
        "A": "Because inheritance follows has-a relationship",
        "B": "Because inheritance follows is-a relationship",
        "C": "Because inheritance doesn’t follow any relationship",
        "D": "Because inheritance is not involved in casting",
        "Answer": "B",
        "Explanation": "The downcasting is possible because the classes in inheritance follow is-a relationship. Hence the derived class is a base class. Which in turn make the downcasting possible",
        "Difficulty": "2",
        "StID": "9"
    },
    {
        "Questions": "What are inbuilt classes?     ",
        "A": "The predefined classes in a language",
        "B": "The classes that are defined by the user",
        "C": "The classes which are meant to be modified by the user",
        "D": "The classes which can’t be used by the user",
        "Answer": "A",
        "Explanation": "The classes that are already provided in a programming language for use are inbuilt classes. These classes provide some functions or objects that can be used by the programmer for easier code.",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": " Inbuilt class ________________________",
        "A": "Must be included before use ",
        "B": "Are not necessary to be included for use",
        "C": "Are used by the compiler only",
        "D": " Can be modified by programmer always",
        "Answer": "A",
        "Explanation": "The inbuilt classes must be included in the program. Whenever some functions are used, they must have a declaration before use. The same is case with classes.",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": " What doesn’t inbuilt classes contain?        ",
        "A": "Function prototype",
        "B": "Function declaration",
        "C": "Function definitions",
        "D": " Objects",
        "Answer": "C",
        "Explanation": "The classes contain the definitions of the special functions that are provided for the programmers use. Those functions can be used to make the programming easy and to reuse the already existing code.",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": "Which among the following not an inbuilt class in C++?        ",
        "A": "System",
        "B": "Color",
        "C": " String",
        "D": "Functions",
        "Answer": "D",
        "Explanation": "There is no inbuilt class named function in java. The others are classes already provided in java. All those classes contain some special functions to be used in programming.",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": "What is InputStream class meant for?       ",
        "A": "To handle all input streams",
        "B": " To handle all output streams",
        "C": "To handle all input and output streams",
        "D": "To handle only input from file",
        "Answer": "A",
        "Explanation": "The InputStream is an inbuilt class which is used to handle all the tasks related to input handling. This class extends input from keyboard or file or any other possible input stream.",
        "Difficulty": "2",
        "StID": "10"
    },
    {
        "Questions": "Which statement is true for Array class?    ",
        "A": "Arrays can have variable length",
        "B": "The length array can be changed",
        "C": "Each class has an associated Array class",
        "D": "Arrays can contain different type of values",
        "Answer": "C",
        "Explanation": "The Array class is associated with all the other classes. This gives us flexibility to declare an array of any type. The index goes from 0 to n, where n is some fixed size for array.",
        "Difficulty": "3",
        "StID": "10"
    },
    {
        "Questions": " What is the use of Math class? ",
        "A": "To use the mathematical functions with strings",
        "B": "To use the mathematical functions",
        "C": "To suppress the use of mathematical functions",
        "D": "To complex the calculations",
        "Answer": "B",
        "Explanation": "The Math class is provided with some special functions. These functions can be used to calculate and get result of some special and usual mathematical functions. We don’t have to write the code to calculate the trigonometric function results, instead we can use Math functions.",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": " DataInputStream is derived from _",
        "A": "StreamingInput",
        "B": "StreamedInput",
        "C": "StreameInput",
        "D": "StreamInput",
        "Answer": "D",
        "Explanation": "The DataInputStream is more specific class for operating on specific type of data inputs. This is used to read data of specific type. The same can be used to read data in a specific format.",
        "Difficulty": "2",
        "StID": "10"
    },
    {
        "Questions": "Which attribute can be used to get the size of an array?     ",
        "A": "Size.Array",
        "B": " Array.Size",
        "C": "Array_name.length",
        "D": "length.Array_name",
        "Answer": "C",
        "Explanation": "The array name is given of which the length have to be calculated. The array length is stored in the attribute length. Hence we access it using dot operator.",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": " Number class can’t manipulate _",
        "A": "Integer values",
        "B": "Float values",
        "C": "Byte values",
        "D": "Character values",
        "Answer": "D",
        "Explanation": "The Number class is used to work with all the number type of values. The integers, float, double, byte etc. are all number type values. Character is not a number value.",
        "Difficulty": "3",
        "StID": "10"
    },
    {
        "Questions": "Which function should be used to exit from the program that is provided by System class?       ",
        "A": "exit(int);",
        "B": "gc();",
        "C": "terminate();",
        "D": " halt();",
        "Answer": "A",
        "Explanation": "The exit function should be used to terminate the program. The function is passed with an argument. The argument indicated the type of error occurred.",
        "Difficulty": "3",
        "StID": "10"
    },
    {
        "Questions": " Which class contain runFinalization() method?   ",
        "A": "Finalize",
        "B": " System",
        "C": "Final",
        "D": "SystemFinal",
        "Answer": "B",
        "Explanation": "The runFinalization() Function is defined in the System class. The function is used to finalize an object which undergo destruction. The action is required to terminate the object properly.advertisement",
        "Difficulty": "2",
        "StID": "10"
    },
    {
        "Questions": "What does load(String)::= function do, in System class?    ",
        "A": "Loads dynamic library for a path name",
        "B": "Loads all the dynamic libraries",
        "C": "Loads all the Number in string format",
        "D": " Loads the processor with calculations",
        "Answer": "A",
        "Explanation": "Only the specified path named dynamic libraries are loaded. All the dynamic libraries can’t be loaded at a time. Hence we use this function for specific libraries.",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": "Which is not a System class variable?  ",
        "A": "err",
        "B": "out",
        "C": "in",
        "D": "put",
        "Answer": "D",
        "Explanation": "Put is not a System class variable. The most general and basic variables are err, out and in. The variables can handle most of the tasks performed in a program.",
        "Difficulty": "2",
        "StID": "10"
    },
    {
        "Questions": "Which package contains the utility classes?    ",
        "A": "java.lang",
        "B": "java.utility",
        "C": "java.util",
        "D": " java.io",
        "Answer": "C",
        "Explanation": "The package java.util contains all the utility classes. This package also contains generic data structures, date, time etc. These can be used in any java program, you just have to include java.util package.",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": "What is the use of IO class?    ",
        "A": "To handle all the input operations",
        "B": "To handle all the output operations",
        "C": "To handle all the input and output operations",
        "D": "To handle all the input and output to the standard input",
        "Answer": "C",
        "Explanation": "The IO class provides functions that can be used to handle input and output operations. All the inputs from standard input and standard output, and also from the files can be handled. This gives flexibility to make the programs more user friendly",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": "IO class provides input and output through __________",
        "A": "Data streams",
        "B": "Serialization",
        "C": "File system",
        "D": "Data streams, serialization and file system",
        "Answer": "D",
        "Explanation": "The IO classes are made such that those can support the input and output from any type of source or destination. The input can be taken from system file and standard input and also some special devices if conned. Same is case to show the output.",
        "Difficulty": "2",
        "StID": "10"
    },
    {
        "Questions": "Which among the following class contains the methods to access character based console device?                   ",
        "A": "Console",
        "B": "File",
        "C": "Device",
        "D": "Pipe",
        "Answer": "A",
        "Explanation": "The Console class contains the methods to access the character based devices. The devices which can stream the data as character set. All those devices can be made use of by using the methods of class Console.",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": "File class is ___",
        "A": "An abstract of file representation only",
        "B": " An abstract of path names only",
        "C": "An abstract which can be used to represent path names or file",
        "D": "An abstract which can represent a file in any format",
        "Answer": "C",
        "Explanation": " The File class is made to operate with the files. The file can be of any type. All the input and output operations that have to be performed on a file can be done using File class",
        "Difficulty": "2",
        "StID": "10"
    },
    {
        "Questions": "What is a FileDescriptor?      ",
        "A": " A handle for machine specific structure of an open file",
        "B": "A handle for program specific structure of an open file",
        "C": "A handle for compiler specific structure of an open file",
        "D": " A handle for representing device files structure",
        "Answer": "A",
        "Explanation": "The machine specific structure of an open file have to be handled in some special ways. FileDescriptor class can handle those files. The FileDescriptor can also handle open socket, another source, sink of bytes.",
        "Difficulty": "3",
        "StID": "10"
    },
    {
        "Questions": "FileInputStream __________",
        "A": " Gets the input stream from any device file",
        "B": " Gets the input stream from any open socket",
        "C": "Gets the input stream from any cache",
        "D": "Gets the input stream from any open file only",
        "Answer": "D",
        "Explanation": "The most specific answer is that the FileInputStream can only be used for the opened files. The class can work only for the file type. No socket or another source are allowed to be accessed.",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": "What does FilePermission class do?    ",
        "A": "This class is used to give permission rights to a file",
        "B": "This class is used to restrict use of permissions",
        "C": "This class is used to represent device access permissions",
        "D": "This class is used to represent file access permissions",
        "Answer": "D",
        "Explanation": "The FilePermission can’t get access to the device access permissions. The Permission is given to a file when it is created or otherwise when a privileged user changes it. Then these permission rights can be accessed using the FilePermission class.",
        "Difficulty": "2",
        "StID": "10"
    },
    {
        "Questions": " Which class among the following makes incorrect assumptions?",
        "A": "LineNumberInputStream ",
        "B": "LineNumberReader",
        "C": "LineReader",
        "D": "LineBuffer",
        "Answer": "A",
        "Explanation": "The LineNumberInputStream class makes false assumptions. The false assumption is that it assumes, all the byte data is a character. Which is actually not the case, instead the character have one byte memory space.",
        "Difficulty": "2",
        "StID": "10"
    },
    {
        "Questions": "Reader class is ______",
        "A": "Used to read from files",
        "B": "Abstract class to read character streams",
        "C": "Abstract class to input character streams",
        "D": "Used to take input from standard input stream",
        "Answer": "B",
        "Explanation": "The Reader class is an abstract class which can be used to read characters stream. It can’t be used for any kind of input. It can just read the existing data.",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": "Which class can handle IO class interrupt?      ",
        "A": "ExceptionIO",
        "B": "InteruptedIO",
        "C": " InteruptedIOException",
        "D": "IOInteruptException",
        "Answer": "C",
        "Explanation": "The only class which handles the IO class interrupts is InteruptedIOException class. This class is specially provided to handle any case that involves the execution interrupt.",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": " StringReader handles ___",
        "A": "Any character stream",
        "B": "A character stream whose source is an array",
        "C": "A character stream whose source is character array",
        "D": "A character stream whose source is String only",
        "Answer": "D",
        "Explanation": "The StringReader can only work with the string type data. Even if a character array is given, it might produce some errors in code. Hence only the string values can be handled properly.               ",
        "Difficulty": "2",
        "StID": "10"
    },
    {
        "Questions": "Which exception handler can be used when character encoding is not supported?",
        "A": "UnsupportedException",
        "B": "UnsupportedEncodingException",
        "C": " SupportException",
        "D": " EncodingException",
        "Answer": "B",
        "Explanation": "The encoding that is unsupported in a system can be handled. The exception handler is UnSupportedEncodingException class. An object of this class can be created which will catch the exception and handle it. advertisement",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": "RandomAccessFile can be used to ___________",
        "A": "Read from a random access file",
        "B": "Write to a random access file",
        "C": "Read and write to a random access file",
        "D": "Restricts read and write to a random access file",
        "Answer": "C",
        "Explanation": "The RandomAccessFile class instance can be created to handle input and output operations to a random access file. It first checks the permissions on the file and then any required operation can be done on a random access file. Comparatively faster than other files access.",
        "Difficulty": "2",
        "StID": "10"
    },
    {
        "Questions": "Which among the following is a serialization descriptor for any class?         ",
        "A": "StreamClass",
        "B": " ObjectStreamClass",
        "C": "ObjectStream",
        "D": "StreamObjectClass",
        "Answer": "B",
        "Explanation": "The ObjectStreamClass object can be created to handle serializations. The class is provided specially for the serializations. It is descriptor like we have a file descriptor to handle/access files",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": "Which is a true statement for object of String class?    ",
        "A": "Object are immutable",
        "B": "Object are mutable",
        "C": "Object are created only once",
        "D": "Object can’t be created",
        "Answer": "A",
        "Explanation": "The object of string class are mostly immutable. This means that the String objects are constant. These can’t be changed once created.",
        "Difficulty": "2",
        "StID": "10"
    },
    {
        "Questions": "How to declare an object of class String? ",
        "A": "String object_Name = value;",
        "B": "String object_name = new;",
        "C": "String object_name= new value;",
        "D": "String object_name= value new;",
        "Answer": "A",
        "Explanation": "The class name String is given. And then the object name is mentioned. There are two ways to declare and initialize the string. Either by giving direct string value or by using new keyword. But if new operator is used, constructor of String class have to be called. From the given options, the direct string value declaration is correct.",
        "Difficulty": "3",
        "StID": "10"
    },
    {
        "Questions": "What does function length do in String class?    ",
        "A": "Returns length of string including null character",
        "B": " Returns length of string excluding null character",
        "C": "Returns length of substring",
        "D": "Returns size of string in bytes",
        "Answer": "B",
        "Explanation": "The length function returns the length of string. The length is the number of characters in the string but the last null character is not counted. The string length can be used to loop through each character in the string.       ",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": "Which is the function to get the character present at a particular index in the string?",
        "A": "char charAt(index);",
        "B": "char charIn(StringName);",
        "C": "char charAt(StringName);",
        "D": "char charIn(index);",
        "Answer": "A",
        "Explanation": "The function can be called using dot operator with the string object. Char is the return type of the function to return the character at specified position. The index must be an integer value, less than the length of string.",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": "If only one parameter is passed to substring function then _____",
        "A": "It returns the character at the specified position",
        "B": "It returns the string of length 1 from the specified index",
        "C": "It returns the string from specified index till the end",
        "D": "It returns the string from starting of string till the specified index",
        "Answer": "B",
        "Explanation": "The substring function returns a string value. The string is the substring starting from the specified index till the end. The substring function have to be called with the object of string class.",
        "Difficulty": "2",
        "StID": "10"
    },
    {
        "Questions": "If two index are given as argument to substring function then ____",
        "A": "String of length equal to sum of two arguments is returned",
        "B": "String starting from first index and of length equal to send argument",
        "C": "String starting from first index and of length equal to sum of two arguments",
        "D": "String starting from first index and ending at second index position",
        "Answer": "D",
        "Explanation": "A value of string type is returned from this function. The returned string is a substring that starts from the first argument position, till the second index position. The indices must be less than the length of actual string.",
        "Difficulty": "2",
        "StID": "10"
    },
    {
        "Questions": "String class have a concat() function that is used to _____",
        "A": "Replace old string by new string",
        "B": " Add two strings",
        "C": "Append one string at end of another string",
        "D": "Remove a string from end of one string",
        "Answer": "C",
        "Explanation": "The concat function is used to append string into another string. The new string is always appended at the end of source string. The target string is appended as it is and the whole string is then ended by null character.",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": "The function lastIndexOf() is used to _____________",
        "A": "Get the index of last occurrence of specified character in argument",
        "B": "Get the index of first occurrence of specified character in argument",
        "C": "Get the index of last occurrence of first character in string",
        "D": "Get the index of last occurrence of last character of string",
        "Answer": "A",
        "Explanation": "The function is used to get the last occurrence index of a character present in a string. The return type is char. Single character is returned. The function is used with a string object and the target character is passed as its argument.",
        "Difficulty": "2",
        "StID": "10"
    },
    {
        "Questions": "Function equals() is _______________ and equalIgnoreCase() is",
        "A": "Case Insensitive, case insensitive",
        "B": "Case sensitive, Case insensitive",
        "C": "Case sensitive, case sensitive",
        "D": "Case insensitive, case sensitive",
        "Answer": "B",
        "Explanation": "Both the functions return Boolean value. The function equal() is case sensitive and returns false even if a single character is case different in two strings. The other function ignores the case sensitivity and only checks if the spellings are same.",
        "Difficulty": "3",
        "StID": "10"
    },
    {
        "Questions": "The compareTo() function is used to _____",
        "A": "Compare strings value to string object",
        "B": "Compare string value to string value",
        "C": "Compare string object to another string object",
        "D": "Compare string object to another string value",
        "Answer": "C",
        "Explanation": "The source and target must be objects of the string class. The compare is always case sensitive. To compare two string objects without case sensitivity then we can use compareToIgnoreCase() function.",
        "Difficulty": "2",
        "StID": "10"
    },
    {
        "Questions": "String class provides function toUpper() to __________",
        "A": "Convert first character to uppercase",
        "B": " Convert last character to uppercase",
        "C": "Convert the whole string characters to uppercase",
        "D": "Convert uppercase to lower and lower to uppercases",
        "Answer": "C",
        "Explanation": "The function is used to convert each character of the string. If the character is already uppercase then it remains the same. But if some character is in lowercase then it will be converted to uppercase.",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": "String trim() function is used to ___",
        "A": "Remove all the white spaces from the string",
        "B": "Remove white space from start of string",
        "C": "Remove white space at end of string",
        "D": "Remove white space from both the ends of string",
        "Answer": "D",
        "Explanation": "The function is used to remove any white space from both the ends of a given string. The white space include space, tab, next line etc. It will be removed both from the starting of string and from end of string. advertisement",
        "Difficulty": "2",
        "StID": "10"
    },
    {
        "Questions": "Function replace() accepts _____________ arguments.",
        "A": "1",
        "B": "2",
        "C": "3",
        "D": "4",
        "Answer": "B",
        "Explanation": "The first argument is the target character. This target character will be replaced by another character. The new character is the second argument to the function. Only the characters can be passed as argument, not a string.",
        "Difficulty": "1",
        "StID": "10"
    },
    {
        "Questions": "If two arguments are passed to the indexOf() function then _________________",
        "A": " Second argument indicates the occurrence number of specified character from starting",
        "B": "Second argument indicates the occurrence number of specified character from end",
        "C": "Second argument indicates the index of the character in first argument",
        "D": "Second argument indicates the index of the character from the last of the string",
        "Answer": "A",
        "Explanation": "The string may have more than one occurrence of a character. We use this function to get the index at which the specified number of times a specific character has occurred in a string. For example, we can get the index of 5th occurrence of character “j” in a string.",
        "Difficulty": "2",
        "StID": "10"
    }
]